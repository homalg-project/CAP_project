<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (CompilerForCAP) - Chapter 3: Examples and tests</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap3"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap2.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chapInd.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap3_mj.html">[MathJax on]</a></p>
<p><a id="X7967FE8E7BBDF485" name="X7967FE8E7BBDF485"></a></p>
<div class="ChapSects"><a href="chap3.html#X7967FE8E7BBDF485">3 <span class="Heading">Examples and tests</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X7A489A5D79DA9E5C">3.1 <span class="Heading">Examples</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X7A810CDA83F2897F">3.2 <span class="Heading">Tests</span></a>
</span>
</div>
</div>

<h3>3 <span class="Heading">Examples and tests</span></h3>

<p><a id="X7A489A5D79DA9E5C" name="X7A489A5D79DA9E5C"></a></p>

<h4>3.1 <span class="Heading">Examples</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "CompilerForCAP" );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># make tests deterministic</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">original_func_id := CAP_JIT_INTERNAL_FUNCTION_ID;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CAP_JIT_INTERNAL_FUNCTION_ID := 1;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># we have to work hard to not write semicolons so AutoDoc</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># does not begin a new statement</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">func := EvalString( ReplacedString( """function( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  local a, b, c, d, e, f, g@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    a := 1@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    if x &lt; 0 then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        b := 2@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        c := 3@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    elif x = 1 then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        c := b@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    else</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        d := a@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        c := a@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    fi@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    e := c@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    if x &lt; 0 then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        return a@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    elif x = 1 then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        return c@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    else</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        f := d@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        g := f@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        return g@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    fi@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end""", "@", ";" ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CapJitPrettyPrintSyntaxTree( tree );</span>
rec(
  0_type := "EXPR_DECLARATIVE_FUNC",
  1_id := 1,
  2_nams := [ "x", "a", "b", "c", "d", "e", "f", "g", "RETURN_VALUE" ],
  3_narg := 1,
  4_variadic := false,
  5_bindings := rec(
      0_type := "FVAR_BINDING_SEQ",
      1_names := [ "RETURN_VALUE", "a", "b", "c", "d", "e", "f", "g" ],
      2_BINDING_RETURN_VALUE := rec(
          0_type := "EXPR_CASE",
          1_branches := rec(
              0__type := "SYNTAX_TREE_LIST",
              0_length := 3,
              1 := rec(
                  0_type := "CASE_BRANCH",
                  1_condition := rec(
                      0_type := "EXPR_LT",
                      1_left := rec(
                          0_type := "EXPR_REF_FVAR",
                          1_func_id := 1,
                          2_name := "x" ),
                      2_right := rec(
                          0_type := "EXPR_INT",
                          1_value := 0 ) ),
                  2_value := rec(
                      0_type := "EXPR_REF_FVAR",
                      1_func_id := 1,
                      2_name := "a" ) ),
              2 := rec(
                  0_type := "CASE_BRANCH",
                  1_condition := rec(
                      0_type := "EXPR_EQ",
                      1_left := rec(
                          0_type := "EXPR_REF_FVAR",
                          1_func_id := 1,
                          2_name := "x" ),
                      2_right := rec(
                          0_type := "EXPR_INT",
                          1_value := 1 ) ),
                  2_value := rec(
                      0_type := "EXPR_REF_FVAR",
                      1_func_id := 1,
                      2_name := "c" ) ),
              3 := rec(
                  0_type := "CASE_BRANCH",
                  1_condition := rec(
                      0_type := "EXPR_TRUE" ),
                  2_value := rec(
                      0_type := "EXPR_REF_FVAR",
                      1_func_id := 1,
                      2_name := "g" ) ) ) ),
      3_BINDING_a := rec(
          0_type := "EXPR_INT",
          1_value := 1 ),
      4_BINDING_b := rec(
          0_type := "EXPR_INT",
          1_value := 2 ),
      5_BINDING_c := rec(
          0_type := "EXPR_CASE",
          1_branches := rec(
              0__type := "SYNTAX_TREE_LIST",
              0_length := 3,
              1 := rec(
                  0_type := "CASE_BRANCH",
                  1_condition := rec(
                      0_type := "EXPR_LT",
                      1_left := rec(
                          0_type := "EXPR_REF_FVAR",
                          1_func_id := 1,
                          2_name := "x" ),
                      2_right := rec(
                          0_type := "EXPR_INT",
                          1_value := 0 ) ),
                  2_value := rec(
                      0_type := "EXPR_INT",
                      1_value := 3 ) ),
              2 := rec(
                  0_type := "CASE_BRANCH",
                  1_condition := rec(
                      0_type := "EXPR_EQ",
                      1_left := rec(
                          0_type := "EXPR_REF_FVAR",
                          1_func_id := 1,
                          2_name := "x" ),
                      2_right := rec(
                          0_type := "EXPR_INT",
                          1_value := 1 ) ),
                  2_value := rec(
                      0_type := "EXPR_REF_FVAR",
                      1_func_id := 1,
                      2_name := "b" ) ),
              3 := rec(
                  0_type := "CASE_BRANCH",
                  1_condition := rec(
                      0_type := "EXPR_TRUE" ),
                  2_value := rec(
                      0_type := "EXPR_REF_FVAR",
                      1_func_id := 1,
                      2_name := "a" ) ) ) ),
      6_BINDING_d := rec(
          0_type := "EXPR_REF_FVAR",
          1_func_id := 1,
          2_name := "a" ),
      7_BINDING_e := rec(
          0_type := "EXPR_REF_FVAR",
          1_func_id := 1,
          2_name := "c" ),
      8_BINDING_f := rec(
          0_type := "EXPR_REF_FVAR",
          1_func_id := 1,
          2_name := "d" ),
      9_BINDING_g := rec(
          0_type := "EXPR_REF_FVAR",
          1_func_id := 1,
          2_name := "f" ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ENHANCED_SYNTAX_TREE_CODE( tree ) );</span>
function ( x_1 )
    local a_1, b_1, c_1, d_1, e_1, f_1, g_1;
    a_1 := 1;
    if x_1 &lt; 0 then
        c_1 := 3;
    elif x_1 = 1 then
        b_1 := 2;
        c_1 := b_1;
    else
        c_1 := a_1;
    fi;
    if x_1 &lt; 0 then
        return a_1;
    elif x_1 = 1 then
        return c_1;
    else
        d_1 := a_1;
        f_1 := d_1;
        g_1 := f_1;
        return g_1;
    fi;
    e_1 := c_1;
    return;
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := EvalString( ReplacedString( """function( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  local y@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    if x &lt; 0 then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        Error( "error" )@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    fi@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    if x = 1 then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        return true@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    fi@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    y := 2@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return false@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end""", "@", ";" ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CapJitPrettyPrintSyntaxTree( tree );</span>
rec(
  0_type := "EXPR_DECLARATIVE_FUNC",
  1_id := 2,
  2_nams := [ "x", "y", "RETURN_VALUE" ],
  3_narg := 1,
  4_variadic := false,
  5_bindings := rec(
      0_type := "FVAR_BINDING_SEQ",
      1_names := [ "RETURN_VALUE", "y" ],
      2_BINDING_RETURN_VALUE := rec(
          0_type := "EXPR_CASE",
          1_branches := rec(
              0__type := "SYNTAX_TREE_LIST",
              0_length := 2,
              1 := rec(
                  0_type := "CASE_BRANCH",
                  1_condition := rec(
                      0_type := "EXPR_EQ",
                      1_left := rec(
                          0_type := "EXPR_REF_FVAR",
                          1_func_id := 2,
                          2_name := "x" ),
                      2_right := rec(
                          0_type := "EXPR_INT",
                          1_value := 1 ) ),
                  2_value := rec(
                      0_type := "EXPR_TRUE" ) ),
              2 := rec(
                  0_type := "CASE_BRANCH",
                  1_condition := rec(
                      0_type := "EXPR_TRUE" ),
                  2_value := rec(
                      0_type := "EXPR_FALSE" ) ) ) ),
      3_BINDING_y := rec(
          0_type := "EXPR_INT",
          1_value := 2 ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CAP_JIT_INTERNAL_FUNCTION_ID := original_func_id;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># check that function stack depth is removed</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">func := x -&gt; y -&gt; 1;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func2 := ENHANCED_SYNTAX_TREE_CODE( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree2 := ENHANCED_SYNTAX_TREE( func2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree.nams = tree2.nams;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree.bindings.BINDING_RETURN_VALUE.nams =</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    tree2.bindings.BINDING_RETURN_VALUE.nams;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># test CAP_JIT_INTERNAL_EXPR_CASE</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">func := { } -&gt; CAP_JIT_INTERNAL_EXPR_CASE( 1 &lt;&gt; 1, 1, true, 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CapJitPrettyPrintSyntaxTree( tree );</span>
rec(
  0_type := "EXPR_DECLARATIVE_FUNC",
  1_id := 1000000004,
  2_nams := [ "RETURN_VALUE" ],
  3_narg := 0,
  4_variadic := false,
  5_bindings := rec(
      0_type := "FVAR_BINDING_SEQ",
      1_names := [ "RETURN_VALUE" ],
      2_BINDING_RETURN_VALUE := rec(
          0_type := "EXPR_CASE",
          1_branches := rec(
              0__type := "SYNTAX_TREE_LIST",
              0_length := 2,
              1 := rec(
                  0_type := "CASE_BRANCH",
                  1_condition := rec(
                      0_type := "EXPR_NE",
                      1_left := rec(
                          0_type := "EXPR_INT",
                          1_value := 1 ),
                      2_right := rec(
                          0_type := "EXPR_INT",
                          1_value := 1 ) ),
                  2_value := rec(
                      0_type := "EXPR_INT",
                      1_value := 1 ) ),
              2 := rec(
                  0_type := "CASE_BRANCH",
                  1_condition := rec(
                      0_type := "EXPR_TRUE" ),
                  2_value := rec(
                      0_type := "EXPR_INT",
                      1_value := 2 ) ) ) ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ENHANCED_SYNTAX_TREE_CODE( tree ) );</span>
function (  )
    if 1 &lt;&gt; 1 then
        return 1;
    else
        return 2;
    fi;
    return;
end
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := HomalgFieldOfRationals();;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">vec := MATRIX_CATEGORY( Q : no_precompiled_code := true );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V := MatrixCategoryObject( vec, 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := ZeroMorphism( V, V );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">beta := IdentityMorphism( V );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">W := DirectSum( V, V );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">morphism_matrix := [ [ alpha, beta ], [ beta, alpha ] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># compile the primitive installation of</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># MorphismBetweenDirectSumsWithGivenDirectSums</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Display(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    vec!.added_functions.MorphismBetweenDirectSumsWithGivenDirectSums[3][1]</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);</span>
function ( cat, S, diagram_S, morphism_matrix, diagram_T, T )
    local underlying_matrix;
    underlying_matrix := List( morphism_matrix, function ( row )
            return List( row, UnderlyingMatrix );
        end );
    underlying_matrix := ListN( diagram_S, underlying_matrix, 
       function ( source, row )
            return UnionOfColumns( homalg_field, Dimension( source ), row );
        end );
    return 
     VectorSpaceMorphism( cat, S, UnionOfRows( homalg_field, Dimension( T ), 
         underlying_matrix ), T );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func1 := CapJitCompiledFunction(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    vec!.added_functions.MorphismBetweenDirectSumsWithGivenDirectSums[3][1],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    vec</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( compiled_func1 );</span>
function ( cat_1, S_1, diagram_S_1, morphism_matrix_1, diagram_T_1, T_1 )
    local hoisted_1_1, deduped_2_1;
    deduped_2_1 := UnderlyingRing( cat_1 );
    hoisted_1_1 := deduped_2_1;
    return ObjectifyMorphismWithSourceAndRangeForCAPWithAttributes( rec(
           ), cat_1, S_1, T_1, UnderlyingMatrix, 
       UnionOfRows( deduped_2_1, Dimension( T_1 ), 
         ListN( diagram_S_1, List( morphism_matrix_1, function ( row_2 )
                  return List( row_2, UnderlyingMatrix );
              end ), function ( source_2, row_2 )
                return UnionOfColumns( hoisted_1_1, Dimension( source_2 ), 
                   row_2 );
            end ) ) );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># compile the default derivation of</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># MorphismBetweenDirectSumsWithGivenDirectSums</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Display(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    vec!.added_functions.MorphismBetweenDirectSumsWithGivenDirectSums[1][1]</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);</span>
function ( cat, S, diagram_S, morphism_matrix, diagram_T, T )
    local test_diagram_product, test_diagram_coproduct;
    test_diagram_coproduct := ListN( diagram_S, morphism_matrix, 
       function ( source, row )
            return UniversalMorphismIntoDirectSumWithGivenDirectSum( cat, 
               diagram_T, source, row, T );
        end );
    return UniversalMorphismFromDirectSumWithGivenDirectSum( cat, diagram_S, 
       T, test_diagram_coproduct, S );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func2 := CapJitCompiledFunction(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    vec!.added_functions.MorphismBetweenDirectSumsWithGivenDirectSums[1][1],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    vec</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( compiled_func2 );</span>
function ( cat_1, S_1, diagram_S_1, morphism_matrix_1, diagram_T_1, T_1 )
    local hoisted_1_1, deduped_2_1;
    deduped_2_1 := UnderlyingRing( cat_1 );
    hoisted_1_1 := deduped_2_1;
    return ObjectifyMorphismWithSourceAndRangeForCAPWithAttributes( rec(
           ), cat_1, S_1, T_1, UnderlyingMatrix, 
       UnionOfRows( deduped_2_1, Dimension( T_1 ), 
         ListN( diagram_S_1, morphism_matrix_1, 
           function ( logic_new_func_x_2, logic_new_func_y_2 )
                return 
                 UnionOfColumns( hoisted_1_1, Dimension( logic_new_func_x_2 )
                    , List( logic_new_func_y_2, function ( s_3 )
                          return UnderlyingMatrix( s_3 );
                      end ) );
            end ) ) );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ENHANCED_SYNTAX_TREE_CODE(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    CapJitCompiledCAPOperationAsEnhancedSyntaxTree( vec, "KernelEmbedding" )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">) );</span>
function ( cat_1, morphism_1 )
    local morphism_attr_1_1;
    morphism_attr_1_1 := SyzygiesOfRows( UnderlyingMatrix( morphism_1 ) );
    return ObjectifyMorphismWithSourceAndRangeForCAPWithAttributes( rec(
           ), cat_1, ObjectifyObjectForCAPWithAttributes( rec(
             ), cat_1, Dimension, NumberRows( morphism_attr_1_1 ) ), 
       Source( morphism_1 ), UnderlyingMatrix, morphism_attr_1_1 );
end
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "LinearAlgebraForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ReadPackage( "LinearAlgebraForCAP", "gap/CompilerLogic.gi" );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QQ := HomalgFieldOfRationals( );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># be careful not to use `MatrixCategory` because attributes are not supported</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">category_constructor := field -&gt; MATRIX_CATEGORY( field );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">given_arguments := [ QQ ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_category_name := "MatrixCategoryPrecompiled";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">package_name := "LinearAlgebraForCAP";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CapJitPrecompileCategoryAndCompareResult(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    category_constructor,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    given_arguments,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    package_name,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    compiled_category_name</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MatrixCategoryPrecompiled( QQ );</span>
Category of matrices over Q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># check that the compiled code is loaded automatically</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># for this, we use the name of the argument of `ZeroObject`:</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># for non-compiled code it is "cat", while for compiled code it is "cat_1"</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">cat := MatrixCategory( QQ );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NamesLocalVariablesFunction( Last( cat!.added_functions.ZeroObject )[1] )[1];</span>
"cat_1"
</pre></div>

<p><a id="X7A810CDA83F2897F" name="X7A810CDA83F2897F"></a></p>

<h4>3.2 <span class="Heading">Tests</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function ( )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #% CAP_JIT_DROP_NEXT_STATEMENT</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    Display( 1 ); return 1; end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( CapJitCompiledFunction( func ) );</span>
function ( )
    return 1;
end
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "CompilerForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "LinearAlgebraForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QQ := HomalgFieldOfRationals( );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cat := MatrixCategory( QQ );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># CapFixpoint with object</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># we have to work hard to not write semicolons so AutoDoc</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># does not begin a new statement</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">func := EvalString( ReplacedString( """function( cat )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  local predicate, func, initial_value@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    predicate := { x, y } -&gt; Dimension( x ) = 3 and Dimension( y ) = 2@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    func := x -&gt; MatrixCategoryObject( cat, Dimension( x ) - 1 )@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    initial_value := MatrixCategoryObject( cat, 10 )@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return CapFixpoint( predicate, func, initial_value )@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end""", "@", ";" ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func( cat );</span>
&lt;A vector space object over Q of dimension 2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( CapJitCompiledFunction( func, cat ) );</span>
function ( cat_1 )
    return ObjectifyObjectForCAPWithAttributes( rec(
           ), cat_1, Dimension, CapFixpoint( function ( x_2, y_2 )
              return x_2 = 3 and y_2 = 2;
          end, function ( x_2 )
              return x_2 - 1;
          end, 10 ) );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># CapFixpoint with morphism</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># we have to work hard to not write semicolons so AutoDoc</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># does not begin a new statement</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">func := EvalString( ReplacedString( """function( cat )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  local obj, predicate, func, initial_value@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    obj := MatrixCategoryObject( cat, 1 )@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    predicate := { x, y } -&gt; IsZeroForMorphisms( cat, y )@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    func := x -&gt; SubtractionForMorphisms( cat, x, x )@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    initial_value := IdentityMorphism( cat, obj )@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return CapFixpoint( predicate, func, initial_value )@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end""", "@", ";" ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func( cat );</span>
&lt;A morphism in Category of matrices over Q&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( CapJitCompiledFunction( func, cat ) );</span>
function ( cat_1 )
    local morphism_attr_1_1, deduped_2_1;
    deduped_2_1 := ObjectifyObjectForCAPWithAttributes( rec(
           ), cat_1, Dimension, 1 );
    morphism_attr_1_1 := CapFixpoint( function ( x_2, y_2 )
            return IsZero( y_2 );
        end, function ( x_2 )
            return x_2 + -1 * x_2;
        end, HomalgIdentityMatrix( 1, UnderlyingRing( cat_1 ) ) );
    return ObjectifyMorphismWithSourceAndRangeForCAPWithAttributes( rec(
           ), cat_1, deduped_2_1, deduped_2_1, UnderlyingMatrix, 
       morphism_attr_1_1 );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># Iterated with list</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">func := { cat, alpha, beta, gamma } -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    Iterated(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [ alpha, beta, gamma ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        { alpha, beta } -&gt; PreCompose( cat, alpha, beta )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( CapJitCompiledFunction( func, cat ) );</span>
function ( cat_1, alpha_1, beta_1, gamma_1 )
    return ObjectifyMorphismWithSourceAndRangeForCAPWithAttributes( rec(
           ), cat_1, Source( alpha_1 ), Range( gamma_1 ), UnderlyingMatrix, 
       UnderlyingMatrix( alpha_1 ) * UnderlyingMatrix( beta_1 ) 
        * UnderlyingMatrix( gamma_1 ) );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># Iterated (case: from_initial_value)</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># PreComposeList</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">func := { cat, morphism_list } -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    Iterated(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        morphism_list,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        { alpha, beta } -&gt; AdditionForMorphisms( cat, alpha, beta )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( CapJitCompiledFunction( func, cat ) );</span>
function ( cat_1, morphism_list_1 )
    local deduped_1_1;
    deduped_1_1 := morphism_list_1[1];
    return ObjectifyMorphismWithSourceAndRangeForCAPWithAttributes( rec(
           ), cat_1, Source( deduped_1_1 ), Range( deduped_1_1 ), 
       UnderlyingMatrix, Iterated( List( morphism_list_1, UnderlyingMatrix )
          , function ( alpha_2, beta_2 )
              return alpha_2 + beta_2;
          end ) );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># Iterated (case: from_compiler_hints)</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># PreComposeList</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">func := { cat, morphism_list } -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    Iterated(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        morphism_list,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        { alpha, beta } -&gt; PreCompose( cat, alpha, beta )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( CapJitCompiledFunction( func, cat ) );</span>
function ( cat_1, morphism_list_1 )
    local morphism_attr_1_1;
    morphism_attr_1_1 := Iterated( List( morphism_list_1, UnderlyingMatrix ), 
       function ( alpha_2, beta_2 )
            return alpha_2 * beta_2;
        end );
    return ObjectifyMorphismWithSourceAndRangeForCAPWithAttributes( rec(
           ), cat_1, ObjectifyObjectForCAPWithAttributes( rec(
             ), cat_1, Dimension, NumberRows( morphism_attr_1_1 ) ), 
       ObjectifyObjectForCAPWithAttributes( rec(
             ), cat_1, Dimension, NumberColumns( morphism_attr_1_1 ) ), 
       UnderlyingMatrix, morphism_attr_1_1 );
end
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "LinearAlgebraForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := HomalgFieldOfRationals();;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rows := MatrixCategory( Q );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MyKernelLift := function( cat, mor, test_mor )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #% CAP_JIT_NEXT_FUNCCALL_DOES_NOT_RETURN_FAIL</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return LiftOrFail( cat, test_mor, KernelEmbedding( cat, mor ) ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V := VectorSpaceObject( 2, Q );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func := CapJitCompiledFunction( MyKernelLift, rows );;</span>
WARNING: Compiling CAP operation LiftOrFail with return_type morphism_or_fail.\
 Operations returning fail usually do not fulfill the requirements that all br\
anches of an if statement can be executed even if the corresponding condition \
does not hold. This might cause errors.
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( compiled_func );</span>
function ( cat_1, mor_1, test_mor_1 )
    local morphism_attr_1_1;
    morphism_attr_1_1 := RightDivide( UnderlyingMatrix( test_mor_1 ), 
       SyzygiesOfRows( UnderlyingMatrix( mor_1 ) ) );
    return ObjectifyMorphismWithSourceAndRangeForCAPWithAttributes( rec(
           ), cat_1, Source( test_mor_1 ), 
       ObjectifyObjectForCAPWithAttributes( rec(
             ), cat_1, Dimension, NumberColumns( morphism_attr_1_1 ) ), 
       UnderlyingMatrix, morphism_attr_1_1 );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func1 := function( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #% CAP_JIT_RESOLVE_FUNCTION</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    if x = 1 then return fail; fi; return 1; end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func2 := function( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #% CAP_JIT_RESOLVE_FUNCTION</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    if x = 1 then return fail; else return 1; fi; end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">call_func1 := function( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #% CAP_JIT_NEXT_FUNCCALL_DOES_NOT_RETURN_FAIL</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return func1( x ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">call_func2 := function( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #% CAP_JIT_NEXT_FUNCCALL_DOES_NOT_RETURN_FAIL</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return func2( x ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( CapJitCompiledFunction( call_func1 ) );</span>
function ( x_1 )
    return 1;
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( CapJitCompiledFunction( call_func2 ) );</span>
function ( x_1 )
    return 1;
end
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "CompilerForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DeclareFilter( "IsMyCat1", IsCapCategory );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DeclareFilter( "IsMyCat2", IsCapCategory );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DeclareOperation( "MyOperation", [ IsMyCat1 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DeclareOperation( "MyOperation", [ IsMyCat2 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InstallMethodForCompilerForCAP( MyOperation, [ IsMyCat1 ], cat -&gt; 1 );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InstallMethodForCompilerForCAP( MyOperation, [ IsMyCat2 ], cat -&gt; 2 );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InstallOtherMethodForCompilerForCAP(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    MyOperation,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [ IsMyCat2, IsInt ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    { cat, int } -&gt; 3</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cat1 := CreateCapCategory( "cat1" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cat2 := CreateCapCategory( "cat2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetFilterObj( cat1, IsMyCat1 );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetFilterObj( cat2, IsMyCat2 );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( CapJitCompiledFunction( cat -&gt; MyOperation( cat ), cat1 ) );</span>
function ( cat_1 )
    return 1;
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( CapJitCompiledFunction( cat -&gt; MyOperation( cat ), cat2 ) );</span>
function ( cat_1 )
    return 2;
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( CapJitCompiledFunction( cat -&gt; MyOperation( cat, 1 ), cat2 ) );</span>
function ( cat_1 )
    return 3;
end
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "CompilerForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "LinearAlgebraForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := HomalgFieldOfRationals();;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">vec := MATRIX_CATEGORY( Q );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># test CapJitCompiledFunction with explicit type signature</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Display(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    CapJitCompiledFunction(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        cat -&gt; ZeroObject( cat ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    filter := IsCapCategory,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    category := vec</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            fail,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        ]</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);</span>
function ( cat_1 )
    return ObjectifyObjectForCAPWithAttributes( rec(
           ), cat_1, Dimension, 0 );
end
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "CompilerForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">##</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># duplicate code inside a function</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">func := function( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return List( [ 1 .. 9 ], y -&gt; (y + (x + 1)) + (y + (x + 1)) ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitDeduplicatedExpressions( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( compiled_func );</span>
function ( x_1 )
    return List( [ 1 .. 9 ], function ( y_2 )
            local deduped_1_2;
            deduped_1_2 := y_2 + (x_1 + 1);
            return deduped_1_2 + deduped_1_2;
        end );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">##</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># duplicate code inside duplicate code</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">func := function( x, y )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return (y + (x + 1) + (x + 1)) + (y + (x + 1) + (x + 1)); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitDeduplicatedExpressions( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( compiled_func );</span>
function ( x_1, y_1 )
    local deduped_1_1, deduped_2_1;
    deduped_2_1 := x_1 + 1;
    deduped_1_1 := y_1 + deduped_2_1 + deduped_2_1;
    return deduped_1_1 + deduped_1_1;
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">##</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># don't deduplicate code accross functions</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">func := function( )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return [ [ x -&gt; (x + 1) + 2 ], [ x -&gt; (x + 1) + 3 ] ]; end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitDeduplicatedExpressions( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( compiled_func );</span>
function (  )
    return [ [ function ( x_2 )
                  return x_2 + 1 + 2;
              end ], [ function ( x_2 )
                  return x_2 + 1 + 3;
              end ] ];
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">##</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># duplicate code inside duplicate code at different function levels</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">func := {} -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    y -&gt; [ [ y, x -&gt; (x + 1) + (x + 1) ], [ y, x -&gt; (x + 1) + (x + 1) ] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitDeduplicatedExpressions( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( compiled_func );</span>
function (  )
    return function ( y_2 )
          local deduped_1_2;
          deduped_1_2 := [ y_2, function ( x_3 )
                    local deduped_1_3;
                    deduped_1_3 := x_3 + 1;
                    return deduped_1_3 + deduped_1_3;
                end ];
          return [ deduped_1_2, deduped_1_2 ];
      end;
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">##</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># deduplication after hoisting in duplicated code</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">func := { f, L } -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [ f( y -&gt; List( L, l -&gt; y + y ) ), f( y -&gt; List( L, l -&gt; y + y ) ) ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitHoistedExpressions( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitDeduplicatedExpressions( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( compiled_func );</span>
function ( f_1, L_1 )
    local deduped_1_1;
    deduped_1_1 := f_1( function ( y_2 )
            local hoisted_1_2;
            hoisted_1_2 := y_2 + y_2;
            return List( L_1, function ( l_3 )
                    return hoisted_1_2;
                end );
        end );
    return [ deduped_1_1, deduped_1_1 ];
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">##</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># make sure that ignoring paths in replaced paths works as expected</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">func := {} -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [ [ [ [ 1 ] ], [ [ 1 ] ] ], [ [ [ 1 ] ], [ [ 1 ] ] ] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitDeduplicatedExpressions( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( compiled_func );</span>
function (  )
    local deduped_1_1, deduped_2_1;
    deduped_2_1 := [ [ 1 ] ];
    deduped_1_1 := [ deduped_2_1, deduped_2_1 ];
    return [ deduped_1_1, deduped_1_1 ];
end
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "CompilerForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := list -&gt; Sum( list[1] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">type_signature := [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            filter := IsList,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            element_type := rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                filter := IsList,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                element_type := rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    filter := IsInt,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    fail,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CapJitDisableDataTypeInference( );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( CapJitCompiledFunction( func, type_signature ) );</span>
function ( list_1 )
    return Sum( list_1[1] );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CapJitEnableDataTypeInference( );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( CapJitCompiledFunction( func, type_signature ) );</span>
function ( list_1 )
    return List( list_1, Sum )[1];
end
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "CompilerForCAP" );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># we have to work hard to not write semicolons so AutoDoc</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># does not begin a new statement</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">func := EvalString( ReplacedString( """function( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  local inner_func1, inner_func2@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    inner_func1 := function( y )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        if y &lt; 1 or y &gt; 10 then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            return 1@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        elif y &gt; 10 then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            return 2@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        else</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            return 3@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        fi@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    end@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    inner_func2 := function( y )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        if y &lt; 1 then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            return 5@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        elif y &gt; 10 then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            return 6@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        elif y &lt; 1 or y &gt; 10 then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            return 7@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        else</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            return 8@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        fi@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    end@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    if IdFunc( false ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        return 0@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    elif x &lt; 1 or x &gt; 10 then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        return inner_func1( x )@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    elif IdFunc( false ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        return 4@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    else</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        return inner_func2( x )@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    fi@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end""", "@", ";" ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func := CapJitCompiledFunction( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( compiled_func );</span>
function ( x_1 )
    if x_1 &lt; 1 or x_1 &gt; 10 then
        return 1;
    else
        return 8;
    fi;
    return;
end
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "CompilerForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># check that CapJitDroppedUnusedBindings is idempotent</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># (one function level)</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">func := function ( )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  local val1, val2; val1 := 1; val2 := val1; return 1; end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitDroppedUnusedBindings( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ENHANCED_SYNTAX_TREE_CODE( tree ) );</span>
function (  )
    return 1;
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree2 := CapJitDroppedUnusedBindings( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ENHANCED_SYNTAX_TREE_CODE( tree2 ) );</span>
function (  )
    return 1;
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree = tree2;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># check that CapJitDroppedUnusedBindings is idempotent</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># (multiple function levels)</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># we have to work hard to not write semicolons so AutoDoc</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># does not begin a new statement</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">func := EvalString( ReplacedString( """function( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  local val1@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    val1 := 1@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return function ( )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      local val2@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        val2 := val1@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        return 1@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    end@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end""", "@", ";" ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitDroppedUnusedBindings( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ENHANCED_SYNTAX_TREE_CODE( tree ) );</span>
function ( x_1 )
    return function (  )
          return 1;
      end;
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree2 := CapJitDroppedUnusedBindings( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ENHANCED_SYNTAX_TREE_CODE( tree2 ) );</span>
function ( x_1 )
    return function (  )
          return 1;
      end;
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree = tree2;</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "CompilerForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">dummy := DummyCategory( rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    list_of_operations_to_install := [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        "IdentityMorphism",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        "ZeroObject",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        "KernelObject",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StopCompilationAtPrimitivelyInstalledOperationsOfCategory( dummy );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CapJitEnableProofAssistantMode( );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func :=</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    cat -&gt; KernelObject( cat, IdentityMorphism( cat, ZeroObject( cat ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( CapJitCompiledFunction( func, dummy ) );</span>
WARNING: the CAP operation KernelObject is not compatible with the congruence \
of morphisms. Keep this in mind when writing logic templates.
WARNING: the CAP operation KernelObject is not compatible with the congruence \
of morphisms. Keep this in mind when writing logic templates.
function ( cat_1 )
    return KernelObject( cat_1, IdentityMorphism( cat_1, ZeroObject( cat_1 ) 
         ) );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CapJitDisableProofAssistantMode( );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( CapJitCompiledFunction( func, dummy ) );</span>
function ( cat_1 )
    return KernelObject( cat_1, IdentityMorphism( cat_1, ZeroObject( cat_1 ) 
         ) );
end
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "CompilerForCAP" );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">##</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># hoisting with deduplication</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">func := function( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return List( [ 1 .. 9 ], y -&gt; (y + (x + 1)) + (y + (x + 1)) ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitHoistedExpressions( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( compiled_func );</span>
function ( x_1 )
    local hoisted_1_1;
    hoisted_1_1 := x_1 + 1;
    return List( [ 1 .. 9 ], function ( y_2 )
            return y_2 + hoisted_1_1 + (y_2 + hoisted_1_1);
        end );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">##</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># hoisting of whole functions</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">func := function( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return List( [ 1 .. 9 ], y -&gt; y + List( [ 1 .. 9 ], z -&gt; x + z ) ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitHoistedExpressions( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( compiled_func );</span>
function ( x_1 )
    local hoisted_1_1;
    hoisted_1_1 := List( [ 1 .. 9 ], function ( z_2 )
            return x_1 + z_2;
        end );
    return List( [ 1 .. 9 ], function ( y_2 )
            return y_2 + hoisted_1_1;
        end );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">##</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># no hoisting of constants</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">func := function( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return List( [ 1 .. 9 ], y -&gt; y + 1 ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitHoistedExpressions( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( compiled_func );</span>
function ( x_1 )
    return List( [ 1 .. 9 ], function ( y_2 )
            return y_2 + 1;
        end );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">##</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># hoisting of returned expressions</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">func := function( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return List( [ 1 .. 9 ], y -&gt; x + 1 ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitHoistedExpressions( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( compiled_func );</span>
function ( x_1 )
    local hoisted_1_1;
    hoisted_1_1 := x_1 + 1;
    return List( [ 1 .. 9 ], function ( y_2 )
            return hoisted_1_1;
        end );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">##</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># hoisting of assigned expressions</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">func := function( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return List( [ 1 .. 9 ], function( y )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        local z; z := x + 1; return z; end ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitHoistedExpressions( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( compiled_func );</span>
function ( x_1 )
    local hoisted_1_1;
    hoisted_1_1 := x_1 + 1;
    return List( [ 1 .. 9 ], function ( y_2 )
            local z_2;
            z_2 := hoisted_1_1;
            return z_2;
        end );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">##</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># hosted expressions inside hosted expressions</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">func := function( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return List( [ 1 .. 9 ], function( y )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        return List( [ 1 .. 9 ], z -&gt; z + (1 + 1) ); end ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitHoistedExpressions( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( compiled_func );</span>
function ( x_1 )
    local hoisted_1_1, hoisted_2_1;
    hoisted_1_1 := 1 + 1;
    hoisted_2_1 := List( [ 1 .. 9 ], function ( z_2 )
            return z_2 + hoisted_1_1;
        end );
    return List( [ 1 .. 9 ], function ( y_2 )
            return hoisted_2_1;
        end );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">##</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># deduplication of more complex trees, e.g. functions</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">func := function( list )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return List( [ 1 .. 9 ], function( y )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        return (y + Sum( list, a -&gt; a )) + Sum( list, a -&gt; a ); end ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitHoistedExpressions( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( compiled_func );</span>
function ( list_1 )
    local hoisted_1_1;
    hoisted_1_1 := Sum( list_1, function ( a_2 )
            return a_2;
        end );
    return List( [ 1 .. 9 ], function ( y_2 )
            return y_2 + hoisted_1_1 + hoisted_1_1;
        end );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">##</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># hosting of expressions in lists, e.g. function call arguments</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">func := function( x, func )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return List( [ 1 .. 9 ], y -&gt; func( x + 1, x + 1, y ) ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitHoistedExpressions( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( compiled_func );</span>
function ( x_1, func_1 )
    local hoisted_1_1;
    hoisted_1_1 := x_1 + 1;
    return List( [ 1 .. 9 ], function ( y_2 )
            return func_1( hoisted_1_1, hoisted_1_1, y_2 );
        end );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">##</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># restrict hoisting to if/else branches (where possible)</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">func := function( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    if x &lt; 0 then return 0; else return y -&gt; [ x + 1, z -&gt; y + 1 ]; fi; end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitHoistedExpressions( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( compiled_func );</span>
function ( x_1 )
    local hoisted_1_1;
    if x_1 &lt; 0 then
        return 0;
    else
        hoisted_1_1 := x_1 + 1;
        return function ( y_2 )
              local hoisted_1_2;
              hoisted_1_2 := y_2 + 1;
              return [ hoisted_1_1, function ( z_3 )
                        return hoisted_1_2;
                    end ];
          end;
    fi;
    return;
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    if x &lt; 0 then return y -&gt; [ x + 1, z -&gt; y + 1 ]; else return 0; fi; end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitHoistedExpressions( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( compiled_func );</span>
function ( x_1 )
    local hoisted_1_1;
    if x_1 &lt; 0 then
        hoisted_1_1 := x_1 + 1;
        return function ( y_2 )
              local hoisted_1_2;
              hoisted_1_2 := y_2 + 1;
              return [ hoisted_1_1, function ( z_3 )
                        return hoisted_1_2;
                    end ];
          end;
    else
        return 0;
    fi;
    return;
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  if x &lt; 0 then return y -&gt; [ y, x+1 ]; else return y -&gt; [ y, x+1 ]; fi; end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitHoistedExpressions( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( compiled_func );</span>
function ( x_1 )
    local hoisted_1_1;
    hoisted_1_1 := x_1 + 1;
    if x_1 &lt; 0 then
        return function ( y_2 )
              return [ y_2, hoisted_1_1 ];
          end;
    else
        return function ( y_2 )
              return [ y_2, hoisted_1_1 ];
          end;
    fi;
    return;
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># CapJitHoistedBindings</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># we have to work hard to not write semicolons so AutoDoc</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># does not begin a new statement</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">func := EvalString( ReplacedString( """function (  )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  local var1, func1, func2@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    var1 := 1@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    func1 := function ( )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      local var2, var3@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        var2 := var1 + 1@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        var3 := var2 + 2@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        return var3@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    end@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    func2 := function ( )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      local var4, var5@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        var4 := var1 + 1@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        var5 := var4 + 2@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        return var5@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    end@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return [ func1, func2 ]@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end""", "@", ";" ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitHoistedBindings( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func := ENHANCED_SYNTAX_TREE_CODE( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( compiled_func );</span>
function (  )
    local var1_1, func1_1, func2_1, hoisted_3_1, hoisted_4_1;
    var1_1 := 1;
    hoisted_3_1 := var1_1 + 1;
    hoisted_4_1 := hoisted_3_1 + 2;
    func2_1 := function (  )
          return hoisted_4_1;
      end;
    func1_1 := function (  )
          return hoisted_4_1;
      end;
    return [ func1_1, func2_1 ];
end
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "CompilerForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "LinearAlgebraForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># check that CapJitInlinedBindings is idempotent</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">func := function ( )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  local val1, val2; val1 := 1; val2 := val1; return val2; end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitInlinedBindings( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ENHANCED_SYNTAX_TREE_CODE( tree ) );</span>
function (  )
    return 1;
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree2 := CapJitInlinedBindings( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ENHANCED_SYNTAX_TREE_CODE( tree2 ) );</span>
function (  )
    return 1;
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree = tree2;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># check that CapJitInlinedBindingsToVariableReferences is idempotent</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">func := function ( )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  local f1, f2; f1 := IdFunc; f2 := f1; return f2; end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitInlinedBindingsToVariableReferences( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ENHANCED_SYNTAX_TREE_CODE( tree ) );</span>
function (  )
    return IdFunc;
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree2 := CapJitInlinedBindingsToVariableReferences( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ENHANCED_SYNTAX_TREE_CODE( tree2 ) );</span>
function (  )
    return IdFunc;
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree = tree2;</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "CompilerForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># make tests deterministic</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">original_func_id := CAP_JIT_INTERNAL_FUNCTION_ID;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CAP_JIT_INTERNAL_FUNCTION_ID := 1;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># check that CapJitInlinedFunctionCalls is idempotent</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">func := function ( )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return (function ( )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        return (function ( )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            return 1; end)( ); end)( ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitInlinedFunctionCalls( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ENHANCED_SYNTAX_TREE_CODE( tree ) );</span>
function (  )
    local inline_2_RETURN_VALUE_1, inline_2_inline_3_RETURN_VALUE_1;
    inline_2_inline_3_RETURN_VALUE_1 := 1;
    inline_2_RETURN_VALUE_1 := inline_2_inline_3_RETURN_VALUE_1;
    return inline_2_RETURN_VALUE_1;
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree2 := CapJitInlinedFunctionCalls( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ENHANCED_SYNTAX_TREE_CODE( tree2 ) );</span>
function (  )
    local inline_2_RETURN_VALUE_1, inline_2_inline_3_RETURN_VALUE_1;
    inline_2_inline_3_RETURN_VALUE_1 := 1;
    inline_2_RETURN_VALUE_1 := inline_2_inline_3_RETURN_VALUE_1;
    return inline_2_RETURN_VALUE_1;
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree = tree2;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CAP_JIT_INTERNAL_FUNCTION_ID := original_func_id;;</span>
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "CompilerForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># test that `CAP_JIT_NOT_RESOLVABLE` does not cause errors when comparing</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># syntax trees</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">DeclareOperation( "MyNonResolvableOperation", [ ] );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := { } -&gt; MyNonResolvableOperation( );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree2 := StructuralCopy( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree2.bindings.BINDING_RETURN_VALUE.funcref.CAP_JIT_NOT_RESOLVABLE := true;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CapJitIsEqualForEnhancedSyntaxTrees( tree, tree2 );</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "LinearAlgebraForCAP" );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := { cat, matrix } -&gt; [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    VectorSpaceMorphism( cat, ObjectConstructor( cat, NumberRows( matrix ) ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        matrix, ObjectConstructor( cat, NrCols( matrix ) ) ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    VectorSpaceMorphism( cat, ObjectConstructor( cat, NumberRows( matrix ) ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        matrix, ObjectConstructor( cat, NrCols( matrix ) ) ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QQ := HomalgFieldOfRationals( );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cat := MatrixCategory( QQ );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( CapJitCompiledFunction( func, cat ) );</span>
function ( cat_1, matrix_1 )
    local morphism_attr_1_1, morphism_attr_2_1;
    morphism_attr_2_1 := matrix_1;
    morphism_attr_1_1 := matrix_1;
    return [ ObjectifyMorphismWithSourceAndRangeForCAPWithAttributes( rec(
               ), cat_1, ObjectifyObjectForCAPWithAttributes( rec(
                 ), cat_1, Dimension, NumberRows( morphism_attr_1_1 ) ), 
           ObjectifyObjectForCAPWithAttributes( rec(
                 ), cat_1, Dimension, NumberColumns( morphism_attr_1_1 ) ), 
           UnderlyingMatrix, morphism_attr_1_1 ), 
        ObjectifyMorphismWithSourceAndRangeForCAPWithAttributes( rec(
               ), cat_1, ObjectifyObjectForCAPWithAttributes( rec(
                 ), cat_1, Dimension, NumberRows( morphism_attr_2_1 ) ), 
           ObjectifyObjectForCAPWithAttributes( rec(
                 ), cat_1, Dimension, NumberColumns( morphism_attr_2_1 ) ), 
           UnderlyingMatrix, morphism_attr_2_1 ) ];
end
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "CompilerForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># check that CapJitResolvedGlobalVariables is idempotent</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">MY_GLOBAL_FUNCTION_1 := function ( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #% CAP_JIT_RESOLVE_FUNCTION</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return x; end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MY_GLOBAL_FUNCTION_2 := function ( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #% CAP_JIT_RESOLVE_FUNCTION</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return MY_GLOBAL_FUNCTION_1( x ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MY_CAP_CATEGORY_1 := CreateCapCategory( );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MY_CAP_CATEGORY_2 := CreateCapCategory( );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetUnderlyingCategory( MY_CAP_CATEGORY_1, MY_CAP_CATEGORY_2 );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DeclareAttribute( "MyAttribute", IsCapCategory );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetMyAttribute( MY_CAP_CATEGORY_2, MY_GLOBAL_FUNCTION_2 );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function ( )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  return MY_GLOBAL_FUNCTION_2( MyAttribute(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        UnderlyingCategory( MY_CAP_CATEGORY_1 )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    ) ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitResolvedGlobalVariables( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ENHANCED_SYNTAX_TREE_CODE( tree ) );</span>
function (  )
    return function ( x_2 )
            return function ( x_3 )
                    return x_3;
                end( x_2 );
        end( function ( x_2 )
            return function ( x_3 )
                    return x_3;
                end( x_2 );
        end );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree2 := CapJitResolvedGlobalVariables( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ENHANCED_SYNTAX_TREE_CODE( tree2 ) );</span>
function (  )
    return function ( x_2 )
            return function ( x_3 )
                    return x_3;
                end( x_2 );
        end( function ( x_2 )
            return function ( x_3 )
                    return x_3;
                end( x_2 );
        end );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree = tree2;</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "CompilerForCAP" );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MY_ID_FUNC := x -&gt; x;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func1 := function( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    if x = 1 then return 1; else return 2; fi; end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree1 := ENHANCED_SYNTAX_TREE( func1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree1.bindings.BINDING_RETURN_VALUE.type = "EXPR_CASE";</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">coded_func1 := ENHANCED_SYNTAX_TREE_CODE( tree1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">String( func1 ) = ReplacedString( String( coded_func1 ), "_1", "" );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree2 := rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    type := "EXPR_DECLARATIVE_FUNC",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    id := 1,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    nams := [ "RETURN_VALUE" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    narg := 0,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    nloc := 1,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    variadic := false,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    bindings := rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        type := "FVAR_BINDING_SEQ",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        length := 1,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        names := [ "RETURN_VALUE" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        BINDING_RETURN_VALUE := rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            type := "EXPR_FUNCCALL",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            funcref := rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                type := "EXPR_REF_GVAR",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                gvar := "MY_ID_FUNC",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            args := AsSyntaxTreeList( [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    type := "EXPR_CASE",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    branches := AsSyntaxTreeList( [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                        rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                            type := "CASE_BRANCH",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                            condition := rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                type := "EXPR_FALSE",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                            ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                            value := rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                type := "EXPR_INT",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                value := 1,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                            ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                        ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                        rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                            type := "CASE_BRANCH",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                            condition := rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                type := "EXPR_TRUE",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                            ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                            value := rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                type := "EXPR_INT",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                value := 2,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                            ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                        ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    ] ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            ] ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">coded_func2 := ENHANCED_SYNTAX_TREE_CODE( tree2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( coded_func2 );</span>
function (  )
    return MY_ID_FUNC( function (  )
              if false then
                  return 1;
              else
                  return 2;
              fi;
              return;
          end(  ) );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">coded_func2();</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># we have to work hard to not write semicolons so AutoDoc</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># does not begin a new statement</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">func3 := EvalString( ReplacedString( """function( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  local my_func, inner_func@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    my_func := MY_ID_FUNC( x -&gt; x )@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    inner_func := function( )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      local y@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        if x then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            return 1@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        else</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            y := 2@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            return y@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        fi@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    end@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return my_func( inner_func( ) )@</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end""", "@", ";" ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func3 := CapJitCompiledFunction( func3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( compiled_func3 );</span>
function ( x_1 )
    local deduped_1_1;
    deduped_1_1 := MY_ID_FUNC( function ( x_2 )
            return x_2;
        end );
    if x_1 then
        return deduped_1_1( 1 );
    else
        return deduped_1_1( 2 );
    fi;
    return;
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func4 := function( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  local y; if x then return 1; else return 1; fi; end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func4 := CapJitCompiledFunction( func4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( compiled_func4 );</span>
function ( x_1 )
    return 1;
end
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "CompilerForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function ( )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  return List( [ 1, 2 ], x -&gt; x ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitAppliedLogic( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ENHANCED_SYNTAX_TREE_CODE( tree ) );</span>
function (  )
    return [ function ( x_2 )
                return x_2;
            end( 1 ), function ( x_2 )
                return x_2;
            end( 2 ) ];
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function ( L1, L2 )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  return List( Concatenation( L1, L2 ), x -&gt; x ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitAppliedLogic( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ENHANCED_SYNTAX_TREE_CODE( tree ) );</span>
function ( L1_1, L2_1 )
    return Concatenation( List( L1_1, function ( x_2 )
              return x_2;
          end ), List( L2_1, function ( x_2 )
              return x_2;
          end ) );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function ( )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  return Concatenation( [ [ 1, 2, 3, 4 ] ] ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitAppliedLogic( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ENHANCED_SYNTAX_TREE_CODE( tree ) );</span>
function (  )
    return [ 1, 2, 3, 4 ];
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function ( )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  return Concatenation( [ [ 1, 2 ], [ 3, 4 ] ] ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitAppliedLogic( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ENHANCED_SYNTAX_TREE_CODE( tree ) );</span>
function (  )
    return [ 1, 2, 3, 4 ];
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function ( )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  return Concatenation( [ 1, 2 ], [ 3, 4 ] ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitAppliedLogic( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ENHANCED_SYNTAX_TREE_CODE( tree ) );</span>
function (  )
    return [ 1, 2, 3, 4 ];
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function ( my_func )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  return CallFuncList( my_func, [ 1, 2 ] ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitAppliedLogic( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ENHANCED_SYNTAX_TREE_CODE( tree ) );</span>
function ( my_func_1 )
    return my_func_1( 1, 2 );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function ( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  if 1 = 2 then return 1; elif x = x then return 2; else return 3; fi; end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitAppliedLogic( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ENHANCED_SYNTAX_TREE_CODE( tree ) );</span>
function ( x_1 )
    if false then
        return 1;
    elif true then
        return 2;
    else
        return 3;
    fi;
    return;
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function ( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  return Length( [ 1, 2, 3 ] ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitAppliedLogic( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ENHANCED_SYNTAX_TREE_CODE( tree ) );</span>
function ( x_1 )
    return 3;
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function ( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  return [ 1 .. 3 ]; end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitAppliedLogic( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ENHANCED_SYNTAX_TREE_CODE( tree ) );</span>
function ( x_1 )
    return [ 1, 2, 3 ];
end
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "CompilerForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># example testing needed_packages</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">template := rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    variable_names := [ "name" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    variable_filters := [ "THIS_SHOULD_NOT_BE_PARSED" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    src_template := "THIS_SHOULD_NOT_BE_PARSED_TOO",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    dst_template := "THIS_SHOULD_NOT_BE_PARSED_EITHER",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    needed_packages := [ [ "NON_EXISTING_PACKAGE", "&gt;= 9999" ] ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Add( CAP_JIT_LOGIC_TEMPLATES, template );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( CapJitCompiledFunction( x -&gt; x ) );</span>
function ( x_1 )
    return x_1;
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIdenticalObj( Remove( CAP_JIT_LOGIC_TEMPLATES ), template );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">applied_logic_template_to_func :=</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    { func, template, type_signature } -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        ENHANCED_SYNTAX_TREE_CODE(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            CAP_JIT_INTERNAL_APPLIED_LOGIC_TEMPLATES(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                CapJitInferredDataTypes(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    ENHANCED_SYNTAX_TREE(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                        func :</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                        type_signature := type_signature</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                [ template ]</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># some general example</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">template := rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    variable_names := [ "variable" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    src_template := "x -&gt; x + variable + x - x",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    dst_template := "x -&gt; x + variable + 0",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CAP_JIT_INTERNAL_ENHANCE_LOGIC_TEMPLATE( template );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function ( a )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return b -&gt; b + ( 2 * b + a ) + b - b; end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( applied_logic_template_to_func( func, template, fail ) );</span>
function ( a_1 )
    return function ( b_2 )
          return b_2 + (2 * b_2 + a_1) + 0;
      end;
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># example using EXPR_CASE</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">template := rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    variable_names := [ "val1", "val2" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    src_template := "CAP_JIT_INTERNAL_EXPR_CASE( 1 &lt;&gt; 1, val1, true, val2 )",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    dst_template := "val2",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CAP_JIT_INTERNAL_ENHANCE_LOGIC_TEMPLATE( template );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function ( )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    if 1 &lt;&gt; 1 then return 1; else return 2; fi; end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( applied_logic_template_to_func( func, template, fail ) );</span>
function ( )
    return 2;
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># check that functions in variables can match</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># and test variable_filters (strings and filters)</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">template := rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    variable_names := [ "L1", "L2", "func" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    variable_filters := [ "IsList", IsList, IsFunction ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    src_template := "Concatenation( [ List( L1, func ), List( L2, func ) ] )",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    dst_template := "List( Concatenation( [ L1, L2 ] ), func )",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CAP_JIT_INTERNAL_ENHANCE_LOGIC_TEMPLATE( template );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := { L1, L2 } -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    Concatenation( [ List( L1, x -&gt; x ), List( L2, x -&gt; x ) ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( applied_logic_template_to_func(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    func,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    template,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            rec( filter := IsList, element_type := rec( filter := IsInt ) ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            rec( filter := IsList, element_type := rec( filter := IsInt ) ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        fail,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    ]</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">) );</span>
function ( L1_1, L2_1 )
    return List( Concatenation( [ L1_1, L2_1 ] ), function ( x_2 )
            return x_2;
        end );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># check that template is not executed if data types cannot be determined</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Display( applied_logic_template_to_func( func, template, fail ) );</span>
function ( L1_1, L2_1 )
    return Concatenation( [ List( L1_1, function ( x_2 )
              return x_2;
          end ), List( L2_1, function ( x_2 )
              return x_2;
          end ) ] );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># check that template is only applied if filters match</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">template := rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    variable_names := [ "value" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    variable_filters := [ IsInt ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    src_template := "Sum( [ value ] )",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    dst_template := "value",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CAP_JIT_INTERNAL_ENHANCE_LOGIC_TEMPLATE( template );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := { x } -&gt; Sum( [ x ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( applied_logic_template_to_func(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    func,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    template,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            rec( filter := IsInt ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        fail,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    ]</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">) );</span>
function ( x_1 )
    return x_1;
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( applied_logic_template_to_func(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    func,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    template,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            rec( filter := IsFloat ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        fail,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    ]</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">) );</span>
function ( x_1 )
    return Sum( [ x_1 ] );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># check that functions can be used multiple times in dst_template</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># add a nonsense template</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">template := rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    variable_names := [ "list", "value" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    src_template := "List( list, l -&gt; value )",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    dst_template := "Sum( list, l -&gt; value ) + Sum( list, l -&gt; value )",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CAP_JIT_INTERNAL_ENHANCE_LOGIC_TEMPLATE( template );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function ( list )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return List( list, x -&gt; x ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( applied_logic_template_to_func( func, template, fail ) );</span>
function ( list_1 )
    return Sum( list_1, function ( x_2 )
              return x_2;
          end ) + Sum( list_1, function ( x_2 )
              return x_2;
          end );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function ( list )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return List( list, x -&gt; (y -&gt; y) ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( applied_logic_template_to_func( func, template, fail ) );</span>
function ( list_1 )
    return Sum( list_1, function ( x_2 )
              return function ( y_3 )
                    return y_3;
                end;
          end ) + Sum( list_1, function ( x_2 )
              return function ( y_3 )
                    return y_3;
                end;
          end );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># check that functions with assignments to local variables do not match</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># logic templates without assignments to local variables</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">template := rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    variable_names := [ "value" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    src_template := "List( [ 1 ], l -&gt; value )",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    dst_template := "(l -&gt; value)(1)",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CAP_JIT_INTERNAL_ENHANCE_LOGIC_TEMPLATE( template );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function ( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return List( [ 1 ], function ( y )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        local r; r := x; return r; end ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( applied_logic_template_to_func( func, template, fail ) );</span>
function ( x_1 )
    return List( [ 1 ], function ( y_2 )
            local r_2;
            r_2 := x_1;
            return r_2;
        end );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># check that values are pulled out iff</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># they are independent of local variables</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">template := rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    variable_names := [ "list", "value" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    src_template := "List( list, l -&gt; value * l )",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    dst_template := "value * List( list, l -&gt; l )",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CAP_JIT_INTERNAL_ENHANCE_LOGIC_TEMPLATE( template );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := L -&gt; List( L, l -&gt; l * l );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( applied_logic_template_to_func( func, template, fail ) );</span>
function ( L_1 )
    return List( L_1, function ( l_2 )
            return l_2 * l_2;
        end );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := L -&gt; List( L, l -&gt; 2 * l );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( applied_logic_template_to_func( func, template, fail ) );</span>
function ( L_1 )
    return 2 * List( L_1, function ( l_2 )
              return l_2;
          end );
end
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := x -&gt; x[1,1];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitResolvedGlobalVariables( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ENHANCED_SYNTAX_TREE_CODE( tree ) );</span>
function ( x_1 )
    return MatElm( x_1, 1, 1 );
end
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "FreydCategoriesForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QQ := HomalgFieldOfRationalsInSingular( );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QQxy := QQ * "x,y";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EEE := KoszulDualRing( QQxy * "a,b" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">precompile_CategoryOfColumns := function( homalg_ring, name )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    CapJitPrecompileCategoryAndCompareResult(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        homalg_ring -&gt; CategoryOfColumnsAsOppositeOfCategoryOfRows(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            homalg_ring</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [ homalg_ring ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        "FreydCategoriesForCAP",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        Concatenation(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            "CategoryOfColumnsAsOppositeOfCategoryOfRowsOf",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            name,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            "Precompiled"</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        ) :</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        operations := "primitive"</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">precompile_CategoryOfColumns( QQ, "Field" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">precompile_CategoryOfColumns( QQxy, "CommutativeRing" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">precompile_CategoryOfColumns( EEE, "ArbitraryRing" );;</span>
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "FreydCategoriesForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ReadPackage( "FreydCategoriesForCAP",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "gap/CategoryOfRowsAsAdditiveClosureOfRingAsCategory_CompilerLogic.gi");</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># We only compile one very special case:</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># The homomorphism structure for homalg exterior rings over fields.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">QQ := HomalgFieldOfRationalsInSingular( );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QQxy := QQ * "x,y";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EEE := KoszulDualRing( QQxy );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">category_constructor :=</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    homalg_ring -&gt; CategoryOfRowsAsAdditiveClosureOfRingAsCategory(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        homalg_ring</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">given_arguments := [ EEE ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">package_name := "FreydCategoriesForCAP";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_category_name := Concatenation(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "CategoryOfRowsAsAdditiveClosureOfRingAsCategoryOf",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "HomalgExteriorRingOverFieldPrecompiled"</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">operations := [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "DistinguishedObjectOfHomomorphismStructure",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "HomomorphismStructureOnObjects",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "HomomorphismStructureOnMorphismsWithGivenObjects",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    Concatenation(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        "InterpretMorphismAsMorphismFromDistinguishedObject",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        "ToHomomorphismStructureWithGivenObjects"</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    Concatenation(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        "InterpretMorphismFromDistinguishedObject",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        "ToHomomorphismStructureAsMorphism"</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CapJitPrecompileCategoryAndCompareResult(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    category_constructor,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    given_arguments,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    package_name,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    compiled_category_name :</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    operations := operations</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># check that the compiled code is loaded automatically</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">cat := CategoryOfRows( EEE );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CanCompute( cat, "HomomorphismStructureOnMorphismsWithGivenObjects" );</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "ModulePresentationsForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QQ := HomalgFieldOfRationalsInSingular( );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QQxy := QQ * "x,y";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EEE := KoszulDualRing( QQxy * "a,b" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># CAUTION: when adding new operations make sure that they are compatible</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># with the ones added manually in `ADD_FUNCTIONS_FOR_LEFT/RIGHT_PRESENTATION`.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">operations_for_arbitrary_ring := [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "AdditionForMorphisms",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "AdditiveInverseForMorphisms",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"AssociatorLeftToRightWithGivenTensorProducts",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"AssociatorRightToLeftWithGivenTensorProducts",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"BraidingWithGivenTensorProducts",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"CoevaluationMorphismWithGivenRange",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "CokernelColiftWithGivenCokernelObject",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "CokernelProjection",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"Colift",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"ColiftOrFail",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "DirectSum",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "EpimorphismFromSomeProjectiveObject",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"EvaluationMorphismWithGivenSource",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "IdentityMorphism",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "InjectionOfCofactorOfDirectSumWithGivenDirectSum",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"InternalHomOnMorphismsWithGivenInternalHoms",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"InternalHomOnObjects",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"IsColiftable",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "IsCongruentForMorphisms",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "IsEqualForMorphisms",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"IsEqualForObjects",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"IsLiftable",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"IsWellDefinedForMorphisms",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"IsWellDefinedForObjects",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "IsZeroForMorphisms",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"KernelEmbedding",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"LeftUnitorWithGivenTensorProduct",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"Lift",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"LiftAlongMonomorphism",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"LiftOrFail",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"MultiplyWithElementOfCommutativeRingForMorphisms",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"PreCompose",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "ProjectionInFactorOfDirectSumWithGivenDirectSum",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"RightUnitorWithGivenTensorProduct",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"TensorProductOnMorphismsWithGivenTensorProducts",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"TensorProductOnObjects",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"TensorUnit",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "UniversalMorphismFromDirectSumWithGivenDirectSum",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "UniversalMorphismFromZeroObjectWithGivenZeroObject",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "UniversalMorphismIntoDirectSumWithGivenDirectSum",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "UniversalMorphismIntoZeroObjectWithGivenZeroObject",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "ZeroMorphism",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "ZeroObject" </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">operations_for_commutative_ring := Concatenation(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    operations_for_arbitrary_ring,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [ "MultiplyWithElementOfCommutativeRingForMorphisms" ]</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">precompile_LeftPresentations := function( ring, name, operations )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    CapJitPrecompileCategoryAndCompareResult(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        ring -&gt; LeftPresentationsAsFreydCategoryOfCategoryOfRows( ring ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [ ring ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        "ModulePresentationsForCAP",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        Concatenation(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            "LeftPresentationsAsFreydCategoryOfCategoryOfRowsOf",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            name,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            "Precompiled"</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        ) :</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        operations := operations</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">precompile_LeftPresentations(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    QQ, "Field", operations_for_commutative_ring</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">precompile_LeftPresentations(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    QQxy, "CommutativeRing", operations_for_commutative_ring</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">precompile_LeftPresentations(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    EEE, "ArbitraryRing", operations_for_arbitrary_ring</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">precompile_RightPresentations := function( ring, name, operations )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    CapJitPrecompileCategoryAndCompareResult(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        ring -&gt; RightPresentationsAsFreydCategoryOfCategoryOfColumns( ring ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [ ring ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        "ModulePresentationsForCAP",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        Concatenation(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            "RightPresentationsAsFreydCategoryOfCategoryOfColumnsOf",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            name,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            "Precompiled"</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        ) :</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        operations := operations</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">precompile_RightPresentations(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    QQ, "Field", operations_for_commutative_ring</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">precompile_RightPresentations(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    QQxy, "CommutativeRing", operations_for_commutative_ring</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">precompile_RightPresentations(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    EEE, "ArbitraryRing", operations_for_arbitrary_ring</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># check that the compiled code is loaded automatically</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># for this, we use the name of the argument of `ZeroObject`:</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># for non-compiled code it is "cat", while for compiled code it is "cat_1"</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">cat := LeftPresentations( QQ );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NamesLocalVariablesFunction( Last( cat!.added_functions.ZeroObject )[1] )[1]</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    = "cat_1";</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cat := LeftPresentations( QQxy );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NamesLocalVariablesFunction( Last( cat!.added_functions.ZeroObject )[1] )[1]</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    = "cat_1";</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cat := LeftPresentations( EEE );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NamesLocalVariablesFunction( Last( cat!.added_functions.ZeroObject )[1] )[1]</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    = "cat_1";</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cat := RightPresentations( QQ );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NamesLocalVariablesFunction( Last( cat!.added_functions.ZeroObject )[1] )[1]</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    = "cat_1";</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cat := RightPresentations( QQxy );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NamesLocalVariablesFunction( Last( cat!.added_functions.ZeroObject )[1] )[1]</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    = "cat_1";</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cat := RightPresentations( EEE );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NamesLocalVariablesFunction( Last( cat!.added_functions.ZeroObject )[1] )[1]</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    = "cat_1";</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QQ := HomalgFieldOfRationals( );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># be careful not to use `MatrixCategory` because attributes are not supported</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">category_constructor := function( field )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return Opposite(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        MATRIX_CATEGORY(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            field :</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            no_precompiled_code := true, FinalizeCategory := true</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        ) :</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        only_primitive_operations := true</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">given_arguments := [ QQ ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_category_name := "OppositeOfMatrixCategoryPrecompiled";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">package_name := "LinearAlgebraForCAP";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CapJitPrecompileCategoryAndCompareResult(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    category_constructor,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    given_arguments,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    package_name,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    compiled_category_name :</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    operations := "primitive"</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ReadPackage(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "LinearAlgebraForCAP",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "gap/precompiled_categories/OppositeOfMatrixCategoryPrecompiled.gi"</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OppositeOfMatrixCategoryPrecompiled( QQ );</span>
Opposite of Category of matrices over Q
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "LinearAlgebraForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := HomalgFieldOfRationals( );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">vec := MATRIX_CATEGORY( Q : no_precompiled_code );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := cat -&gt; ZeroObjectFunctorial( cat );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StopCompilationAtCategory( vec );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( CapJitCompiledFunction( func, vec ) );</span>
function ( cat_1 )
    return ZeroObjectFunctorial( cat_1 );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ContinueCompilationAtCategory( vec );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( CapJitCompiledFunction( func, vec ) );</span>
function ( cat_1 )
    local morphism_attr_1_1, deduped_2_1;
    deduped_2_1 := ObjectifyObjectForCAPWithAttributes( rec(
           ), cat_1, Dimension, 0 );
    morphism_attr_1_1 
     := HomalgZeroMatrix( 0, 0, UnderlyingRing( cat_1 ) );
    return ObjectifyMorphismWithSourceAndRangeForCAPWithAttributes
        ( rec(
           ), cat_1, deduped_2_1, deduped_2_1, UnderlyingMatrix, 
       morphism_attr_1_1 );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">vec := MATRIX_CATEGORY( Q : no_precompiled_code );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StopCompilationAtPrimitivelyInstalledOperationsOfCategory( vec );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( CapJitCompiledFunction( func, vec ) );</span>
WARNING: Could not find declaration of ZeroObject (current input: \
[ &lt;Category "IsMatrixCategory"&gt; ])
WARNING: Could not find declaration of ZeroObject (current input: \
[ &lt;Category "IsMatrixCategory"&gt; ])
WARNING: Could not find declaration of ZeroObject (current input: \
[ &lt;Category "IsMatrixCategory"&gt; ])
function ( cat_1 )
    local deduped_1_1;
    deduped_1_1 := ZeroObject( cat_1 );
    return ZeroMorphism( cat_1, deduped_1_1, deduped_1_1 );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ContinueCompilationAtPrimitivelyInstalledOperationsOfCategory( vec );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( CapJitCompiledFunction( func, vec ) );</span>
function ( cat_1 )
    local morphism_attr_1_1, deduped_2_1;
    deduped_2_1 := ObjectifyObjectForCAPWithAttributes( rec(
           ), cat_1, Dimension, 0 );
    morphism_attr_1_1 
     := HomalgZeroMatrix( 0, 0, UnderlyingRing( cat_1 ) );
    return ObjectifyMorphismWithSourceAndRangeForCAPWithAttributes
        ( rec(
           ), cat_1, deduped_2_1, deduped_2_1, UnderlyingMatrix, 
       morphism_attr_1_1 );
end
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := HomalgFieldOfRationals();;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">vec := MATRIX_CATEGORY( Q );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function ( cat, x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #% CAP_JIT_RESOLVE_FUNCTION</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return ZeroObject( cat ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># make sure that ZeroObject( cat ) is not resolved to a global variable</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Display( CapJitCompiledFunction( { cat, x } -&gt; func( cat, x ), vec ) );</span>
function ( cat_1, x_1 )
    return ObjectifyObjectForCAPWithAttributes( rec(
           ), cat_1, Dimension, 0 );
end
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function ( )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  local x; x := { args... } -&gt; 1; return x( ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( CapJitCompiledFunction( func ) );</span>
function ( )
    return 1;
end
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func1 := function( x, y )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #% CAP_JIT_RESOLVE_FUNCTION</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return x; end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func2 := function( )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  local var; var := 1; var := func1( 2, var ); return var; end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func := CapJitCompiledFunction( func2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func();</span>
2
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function( )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  local id; id := y -&gt; y; return [ id, id ]; end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># we are not interested in the output, but only that this does not throw</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># an error due to some function id being used multiple times</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">CapJitCompiledFunction( func );;</span>
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap2.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chapInd.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
