<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (CompilerForCAP) - Chapter 1: Using the compiler</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap1"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap0_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap2_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap1.html">[MathJax off]</a></p>
<p><a id="X8465664B7FDF3EDA" name="X8465664B7FDF3EDA"></a></p>
<div class="ChapSects"><a href="chap1_mj.html#X8465664B7FDF3EDA">1 <span class="Heading">Using the compiler</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1_mj.html#X8578A2598059B94F">1.1 <span class="Heading">Terminology</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1_mj.html#X83E04B937E74DD2A">1.2 <span class="Heading">Capabilities of the compiler</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1_mj.html#X85A08CF187A6D986">1.3 <span class="Heading">Requirements</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1_mj.html#X7A502E2F78A33B91">1.4 <span class="Heading">Activating the compiler</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1_mj.html#X7C1A71BB7DC16DDF">1.5 <span class="Heading">Stopping the compiler at a certain level</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X85B3DF4C80406968">1.5-1 StopCompilationAtCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7ECBAF2483705ED2">1.5-2 ContinueCompilationAtCategory</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1_mj.html#X7B946AD083F7CEEA">1.6 <span class="Heading">Getting information about the compilation process</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X8202365E84A044DC">1.6-1 InfoCapJit</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1_mj.html#X78F1B59B7DBEF671">1.7 <span class="Heading">Compiling a function manually</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X86F1D06C81670DC8">1.7-1 CapJitCompiledFunction</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1_mj.html#X780099B481AB3AB7">1.8 <span class="Heading">FAQ</span></a>
</span>
</div>
</div>

<h3>1 <span class="Heading">Using the compiler</span></h3>

<p><em>WARNING</em>: This package is still in alpha and not tested or validated extensively!</p>

<p><a id="X8578A2598059B94F" name="X8578A2598059B94F"></a></p>

<h4>1.1 <span class="Heading">Terminology</span></h4>

<p>The compiler is a just-in-time compiler, that is, it needs some arguments to infer types of variables. These arguments are refered to as <em>JIT arguments</em>. For a given CAP operation, these are usually the arguments of the first call of the operation.</p>

<p>The compiler uses GAP's syntax trees for optimizing functions. The term <em>tree</em> always refers to the syntax tree of the function to be compiled. Note that a node of the tree always knows its children, so technically it is also a tree. That is, the terms <em>tree</em>, <em>subtree</em>, and <em>node</em> technically describe the same thing but we use them for different emphases.</p>

<p>We often replace a node in the tree by another tree representing the "value" of the original node. Examples:</p>


<ul>
<li><p>Replace a global variable referencing an integer, a string, or a boolean by EXPR_INT, EXPR_STRING, EXPR_TRUE or EXPR_FALSE.</p>

</li>
<li><p>Replace a global variable referencing a plain function by the syntax tree of this function.</p>

</li>
<li><p>Replace a record access of a global function by the value of this record access.</p>

</li>
<li><p>Replace an operation by a concrete method.</p>

</li>
</ul>
<p>We call this <em>resolving</em> the global variable, operation, etc. Note that this does not change the basic "layout" of the tree.</p>

<p>On the contrary, in the following examples we change the "layout" of the tree:</p>


<ul>
<li><p>If we have a function call of a resolved function, we can assign the argument values to local variables at the beginning of the function. This way we can avoid passing arguments completely.</p>

</li>
<li><p>If a function call of a resolved function occurs in the right hand side of a variable assignment, we can insert the body of the resolved function right before the variable assignment. This way we can avoid the function call.</p>

</li>
<li><p>We can replace all references to a local variable by the right hand side of the variable assignment and then drop the assignment.</p>

</li>
</ul>
<p>We call this <em>inlining</em> the function arguments, functions, or variable assignments.</p>

<p><a id="X83E04B937E74DD2A" name="X83E04B937E74DD2A"></a></p>

<h4>1.2 <span class="Heading">Capabilities of the compiler</span></h4>

<p>The compilation process has two phases: the resolving phase and the rule phase.</p>

<p>During the resolving phase, operations and global variables are resolved:</p>


<ul>
<li><p>An operation is resolved by executing the function to be compiled with the JIT arguments to determine the arguments of the operation. These arguments are used to call <code class="code">ApplicableMethod</code>, and methods annotated with the pragma <code class="code">CAP_JIT_RESOLVE_FUNCTION</code> are resolved.</p>

</li>
<li><p>CAP operations are handled separately: instead of using <code class="code">ApplicableMethod</code>, the functions added to the category via <code class="code">Add</code> functions are considered, and those do not have to be annotated with <code class="code">CAP_JIT_RESOLVE_FUNCTION</code>. In particular, caching, pre functions, etc. are bypassed.</p>

</li>
<li><p>References to global functions are resolved if the function is annotated with the pragma <code class="code">CAP_JIT_RESOLVE_FUNCTION</code>.</p>

</li>
</ul>
<p>For details see <code class="func">CapJitResolvedOperations</code> (<a href="chap2_mj.html#X7D12C378812745DA"><span class="RefLink">2.5-10</span></a>) and <code class="func">CapJitResolvedGlobalVariables</code> (<a href="chap2_mj.html#X7FD883BA85F7EBE5"><span class="RefLink">2.5-9</span></a>). If no operation or global variable can be resolved anymore, we continue with the rule phase.</p>

<p>In the rule phase, the tree is optimized using several rules and techniques. Function arguments, functions, and assignments to local variables are inlined. Unused variables are dropped. Handled edge cases are dropped, that is, if the same edge case is caught multiple times via <code class="code">if condition then return ...; fi;</code> statements, only the first such statement is kept. Finally, "logic" is applied to the tree. For example, calls of <code class="code">CallFuncList</code> are replaced by calls to the actual function. The logic can be extended by the user, see chapter <a href="chap2_mj.html#X7D62EFD07F991E56"><span class="RefLink">2</span></a>.</p>

<p>For all details, see the list of compilations steps in <a href="chap2_mj.html#X80608A9A78CF95E0"><span class="RefLink">2.5</span></a>.</p>

<p><a id="X85A08CF187A6D986" name="X85A08CF187A6D986"></a></p>

<h4>1.3 <span class="Heading">Requirements</span></h4>

<p>There are three main requirements for the steps described above to be correct:</p>


<ul>
<li><p>The code must not depend on side effects (otherwise dropping "unused" variables or inlining variables could change results). See <code class="func">CapJitThrowErrorOnSideEffects</code> (<a href="chap2_mj.html#X7D78F2228335D1F8"><span class="RefLink">2.4-8</span></a>) for details.</p>

</li>
<li><p>The methods selected for the operations during the resolving phase must be independent of the JIT arguments, that is, they must yield correct results for all allowed arguments of the function to be compiled. Thus, be careful which methods you annotate with <code class="code">CAP_JIT_RESOLVE_FUNCTION</code>. In particular, the CAP categories of objects and morphisms appearing during the execution must be independent of the JIT arguments.</p>

</li>
<li><p>All results of applications of filters in logic templates must be independent of the JIT arguments. Thus, be careful when adding new logic templates.</p>

</li>
</ul>
<p>There is an additional weak requirement: The compiler mainly optimizes the code paths covered when executing the function with the JIT arguments. Thus, the JIT arguments should represent a "generic" call, i.e., they should not run into edge cases which do not happen with a "generic" call. Still, the execution using JIT arguments should be fast to improve compilation times.</p>

<p>Additionally, there is not detection for recursive function calls currently, so resolving such a function call leads to an infinite loop.</p>

<p><a id="X7A502E2F78A33B91" name="X7A502E2F78A33B91"></a></p>

<h4>1.4 <span class="Heading">Activating the compiler</span></h4>

<p>You can activate the compiler by passing the option <code class="code">enable_compilation</code> to any category constructor. If <code class="code">enable_compilation</code> is set to <code class="code">true</code>, any basic operation will be compiled when called for the first time. If <code class="code">enable_compilation</code> is a list of strings, compilation will only happen if the function name of the basic operation appears in this list.</p>

<p><a id="X7C1A71BB7DC16DDF" name="X7C1A71BB7DC16DDF"></a></p>

<h4>1.5 <span class="Heading">Stopping the compiler at a certain level</span></h4>

<p>You can use <code class="code">StopCompilationAtCategory</code> to prevent the compiler from inlining and optimizing code of a given category. You can revert this decision using <code class="code">ContinueCompilationAtCategory</code>.</p>

<p><a id="X85B3DF4C80406968" name="X85B3DF4C80406968"></a></p>

<h5>1.5-1 StopCompilationAtCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; StopCompilationAtCategory</code>( <var class="Arg">category</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Stops the compiler from inlining and optimizing code of <var class="Arg">category</var>.</p>

<p><a id="X7ECBAF2483705ED2" name="X7ECBAF2483705ED2"></a></p>

<h5>1.5-2 ContinueCompilationAtCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ContinueCompilationAtCategory</code>( <var class="Arg">category</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Allows the compiler to inline and optimize code of <var class="Arg">category</var> (this is the default).</p>

<p><a id="X7B946AD083F7CEEA" name="X7B946AD083F7CEEA"></a></p>

<h4>1.6 <span class="Heading">Getting information about the compilation process</span></h4>

<p>You can increase the info level of <code class="code">InfoCapJit</code> to get information about the compilation process.</p>

<p><a id="X8202365E84A044DC" name="X8202365E84A044DC"></a></p>

<h5>1.6-1 InfoCapJit</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InfoCapJit</code></td><td class="tdright">(&nbsp;info class&nbsp;)</td></tr></table></div>
<p>Info class used for info messsages of the CAP compiler.</p>

<p><a id="X78F1B59B7DBEF671" name="X78F1B59B7DBEF671"></a></p>

<h4>1.7 <span class="Heading">Compiling a function manually</span></h4>

<p>Use <code class="func">CapJitCompiledFunction</code> (<a href="chap1_mj.html#X86F1D06C81670DC8"><span class="RefLink">1.7-1</span></a>) to compile a function <code class="code">func</code> with JIT arguments <code class="code">jit_args</code>. <code class="code">jit_args</code> should represent a "generic" call, i.e., they should not run into edge cases which do not happen with a "generic" call. Still, the execution using <code class="code">jit_args</code> should be fast to improve compilation times.</p>

<p><a id="X86F1D06C81670DC8" name="X86F1D06C81670DC8"></a></p>

<h5>1.7-1 CapJitCompiledFunction</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitCompiledFunction</code>( <var class="Arg">func</var>, <var class="Arg">jit_args</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a function</p>

<p>Returns a compiled version of the function <var class="Arg">func</var>. The arguments <var class="Arg">jit_args</var> are used to infer the types of variables.</p>

<p><a id="X780099B481AB3AB7" name="X780099B481AB3AB7"></a></p>

<h4>1.8 <span class="Heading">FAQ</span></h4>


<ul>
<li><p>Q: Why is my function not resolved?</p>

</li>
</ul>
<p>A: Only functions annotated with the pragma <code class="code">CAP_JIT_RESOLVE_FUNCTION</code> are resolved. Additionally, a function can only be resolved if it appears as a global variable in the tree during the resolving phase of the compilation. That is, it must be referenced from a global variable from the beginning on, or after global variables are resolved by <code class="func">CapJitResolvedGlobalVariables</code> (<a href="chap2_mj.html#X7FD883BA85F7EBE5"><span class="RefLink">2.5-9</span></a>). Possibly you have adapt <code class="func">CapJitResolvedGlobalVariables</code> (<a href="chap2_mj.html#X7FD883BA85F7EBE5"><span class="RefLink">2.5-9</span></a>) to your setting.</p>


<ul>
<li><p>Q: Why is my operation not resolved?</p>

</li>
</ul>
<p>A: The compiler must be able to get the arguments of the call of the operation from the JIT arguments. Then the rules in the description of <code class="func">CapJitResolvedOperations</code> (<a href="chap2_mj.html#X7D12C378812745DA"><span class="RefLink">2.5-10</span></a>) apply.</p>


<ul>
<li><p>Q: Why do I get the error "cannot find iteration key"?</p>

</li>
</ul>
<p>A: For each syntax tree node type, the tree iterator has to know which record names it should use for continuing the iteration. Please add the missing keys to <code class="code">CAP_INTERNAL_JIT_ITERATION_KEYS</code>.</p>


<ul>
<li><p>Q: Why do I get the error "tree has no kown type" when calling <code class="func">CapJitPrettyPrintSyntaxTree</code> (<a href="chap2_mj.html#X868F5CD681DAFA69"><span class="RefLink">2.4-3</span></a>)?</p>

</li>
</ul>
<p>A: <code class="func">CapJitPrettyPrintSyntaxTree</code> (<a href="chap2_mj.html#X868F5CD681DAFA69"><span class="RefLink">2.4-3</span></a>) needs to handle every syntax tree node type separately. Please add the missing type to <code class="func">CapJitPrettyPrintSyntaxTree</code> (<a href="chap2_mj.html#X868F5CD681DAFA69"><span class="RefLink">2.4-3</span></a>).</p>


<ul>
<li><p>Q: Why is do I get the error "a local variable with name &lt;name&gt; is assigned more than once (not as a part of a rapid reassignment), this is not supported"?</p>

</li>
</ul>
<p>A: For reasons of correctness, variables cannot be inlined if a variable is assigned more than once in the body of a function (this includes function arguments which are assigned at least once, namely when the function is called). An exception is made for "rapid reassignments": if the same variable is assigned and then reassigned immediately in the next statement, this only counts as a single assignment.</p>


<ul>
<li><p>Q: Why do I get one of the following errors: "tree includes statements or expressions which indicate possible side effects", "tree contains an assignment of a higher variable with initial name &lt;name&gt;, this is not supported", or "tree contains for loop over non-local variable, this is not supported" ?</p>

</li>
</ul>
<p>A: We can only drop unused variables, inline variables, etc. if we assume that the code contains no side effects. Statements like STAT_PROCCALL or assignment to higher variables cause (or at least indicate) side effects, so continuing with the compilation would probably not lead to a correct result.</p>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap0_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap2_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
