<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (CompilerForCAP) - Chapter 1: Using the compiler</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap1"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap0_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap2_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap1.html">[MathJax off]</a></p>
<p><a id="X8465664B7FDF3EDA" name="X8465664B7FDF3EDA"></a></p>
<div class="ChapSects"><a href="chap1_mj.html#X8465664B7FDF3EDA">1 <span class="Heading">Using the compiler</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1_mj.html#X8578A2598059B94F">1.1 <span class="Heading">Terminology</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1_mj.html#X83E04B937E74DD2A">1.2 <span class="Heading">Capabilities of the compiler</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1_mj.html#X85A08CF187A6D986">1.3 <span class="Heading">Requirements</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1_mj.html#X8307AD6B823FB122">1.4 <span class="Heading">Precompiling categories</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X81627716853DCE40">1.4-1 CapJitPrecompileCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X819343157D62111A">1.4-2 CapJitPrecompileCategoryAndCompareResult</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1_mj.html#X78F1B59B7DBEF671">1.5 <span class="Heading">Compiling a function manually</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X87BAEADB78CC3FF0">1.5-1 CapJitCompiledCAPOperationAsEnhancedSyntaxTree</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X86F1D06C81670DC8">1.5-2 CapJitCompiledFunction</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7B1445EE85D8CA0A">1.5-3 CapJitCompiledFunctionAsEnhancedSyntaxTree</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1_mj.html#X7E61259E7D6E8EEB">1.6 <span class="Heading">Giving hints to the compiler</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1_mj.html#X7C1A71BB7DC16DDF">1.7 <span class="Heading">Stopping the compiler at a certain level</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X85B3DF4C80406968">1.7-1 StopCompilationAtCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7ECBAF2483705ED2">1.7-2 ContinueCompilationAtCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X80ABBF057E2687E1">1.7-3 StopCompilationAtPrimitivelyInstalledOperationsOfCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X86EE97ED7A87D7CC">1.7-4 ContinueCompilationAtPrimitivelyInstalledOperationsOfCategory</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1_mj.html#X7F76759D7D772538">1.8 <span class="Heading">Disabling the automatic inference of data types</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X843286607CD2DE7E">1.8-1 CapJitDisableDataTypeInference</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1_mj.html#X8517503D80444503">1.9 <span class="Heading">Proof assistant mode</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X795104B985A220EE">1.9-1 CapJitEnableProofAssistantMode</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1_mj.html#X7B946AD083F7CEEA">1.10 <span class="Heading">Getting information about the compilation process</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X8202365E84A044DC">1.10-1 InfoCapJit</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1_mj.html#X780099B481AB3AB7">1.11 <span class="Heading">FAQ</span></a>
</span>
</div>
</div>

<h3>1 <span class="Heading">Using the compiler</span></h3>

<p><a id="X8578A2598059B94F" name="X8578A2598059B94F"></a></p>

<h4>1.1 <span class="Heading">Terminology</span></h4>

<p>The compiler was started as a just-in-time compiler, that is, it needed some arguments to infer types of variables. Although the compiler now supports precompilation and type signatures can be explicitly given, it still is a just-in-time compiler in the following sense: Only methods for operations getting a CAP category as the first argument can be found by the compiler, and an instance of a CAP category is needed for method selection.</p>

<p>The compiler uses GAP's syntax trees for optimizing functions. The term <em>tree</em> always refers to the syntax tree of the function to be compiled. Note that a node of the tree always knows its children, so technically it is also a tree. That is, the terms <em>tree</em>, <em>subtree</em>, and <em>node</em> technically describe the same thing but we use them for different emphases.</p>

<p>We often replace a node in the tree by another tree representing the "value" of the original node. Examples:</p>


<ul>
<li><p>Replace a global variable referencing an integer, a string, or a boolean by EXPR_INT, EXPR_STRING, EXPR_TRUE or EXPR_FALSE.</p>

</li>
<li><p>Replace a global variable referencing a plain function by the syntax tree of this function.</p>

</li>
<li><p>Replace a record access of a global function by the value of this record access.</p>

</li>
<li><p>Replace an operation by a concrete method.</p>

</li>
</ul>
<p>We call this <em>resolving</em> the global variable, operation, etc. Note that this does not change the basic "layout" of the tree.</p>

<p>On the contrary, in the following examples we change the "layout" of the tree:</p>


<ul>
<li><p>If we have a function call of a resolved function, we can assign the argument values to local variables at the beginning of the function. This way we can avoid passing arguments completely.</p>

</li>
<li><p>If a function call of a resolved function occurs in the right hand side of a variable assignment, we can insert the body of the resolved function right before the variable assignment. This way we can avoid the function call.</p>

</li>
<li><p>We can replace all references to a local variable by the right hand side of the variable assignment and then drop the assignment.</p>

</li>
</ul>
<p>We call this <em>inlining</em> the function arguments, functions, or variable assignments.</p>

<p><a id="X83E04B937E74DD2A" name="X83E04B937E74DD2A"></a></p>

<h4>1.2 <span class="Heading">Capabilities of the compiler</span></h4>

<p>The compilation process has two phases: the resolving phase and the rule phase.</p>

<p>During the resolving phase, operations and global variables are resolved.</p>


<ul>
<li><p>CAP operations can only be resolved if an instance of a CAP category to which the operation is applied is known. Then, the functions added to the category via <code class="code">Add</code> functions are considered. Note that caching, pre functions, etc. are bypassed.</p>

</li>
<li><p>You can also use <code class="code">InstallMethodForCompilerForCAP</code> or <code class="code">InstallOtherMethodForCompilerForCAP</code> (see the documentation of CAP) to make methods which accept a CAP category as the first argument known to the compiler. The same restrictions as for CAP operations apply.</p>

</li>
<li><p>References to global functions are resolved if the function name is not listed in <code class="code">CAP_JIT_NON_RESOLVABLE_GLOBAL_VARIABLE_NAMES</code> and if the function is annotated with the pragma <code class="code">CAP_JIT_RESOLVE_FUNCTION</code>.</p>

</li>
<li><p>If a call of a global function or operation (occuring as the right hand side of a variable assignment or as the return value of a function) is annotated with the pragma <code class="code">CAP_JIT_NEXT_FUNCCALL_DOES_NOT_RETURN_FAIL</code>, the compiler assumes that the resolved function never returns <code class="code">fail</code> and thus simply removes any code of the form <code class="code">if condition then return fail; fi;</code> (or similar) from the resolved function. The pragma has to be placed right before the variable assignment or the return statement.</p>

</li>
<li><p>If the pragma <code class="code">CAP_JIT_DROP_NEXT_STATEMENT</code> occurs in the resolved function, the statement following the pragma is removed.</p>

</li>
</ul>
<p>For details see <code class="func">CapJitResolvedOperations</code> (<a href="chap2_mj.html#X7D12C378812745DA"><span class="RefLink">2.5-20</span></a>) and <code class="func">CapJitResolvedGlobalVariables</code> (<a href="chap2_mj.html#X7FD883BA85F7EBE5"><span class="RefLink">2.5-19</span></a>). If no operation or global variable can be resolved anymore, we continue with the rule phase.</p>

<p>In the rule phase, the tree is optimized using several rules and techniques. Function arguments, functions, and assignments to local variables are inlined. Unused variables are dropped. Handled edge cases are dropped, that is, if the same edge case is caught multiple times via <code class="code">if condition then return ...; fi;</code> statements, only the first such statement is kept. Finally, "logic" is applied to the tree. For example, calls of <code class="code">CallFuncList</code> are replaced by calls to the actual function. The logic can be extended by the user, see chapter <a href="chap2_mj.html#X7D62EFD07F991E56"><span class="RefLink">2</span></a>.</p>

<p>For all details, see the list of compilations steps in <a href="chap2_mj.html#X80608A9A78CF95E0"><span class="RefLink">2.5</span></a>.</p>

<p><a id="X85A08CF187A6D986" name="X85A08CF187A6D986"></a></p>

<h4>1.3 <span class="Heading">Requirements</span></h4>

<p>There are some requirements for the steps described above to be correct:</p>


<ul>
<li><p>The code must not depend on side effects (otherwise dropping "unused" variables or inlining variables could change results).</p>

</li>
<li><p>Technically, the result is only valid for the concrete CAP category which was used to resolve CAP operations and get typing information. That is, for parametric categories you must check manually for which parameters the result is valid.</p>

</li>
<li><p>Only assignments to local variables, if/elif/else statements, and return statements are allowed as statements in functions.</p>

</li>
<li><p>All branches of any given if/elif/else statement must end with a return statement or the assignment to the same local variable.</p>

</li>
<li><p>If statements must always have an else statement, except if all branches end with a return statement. In the latter case, the statements following the if statement are automatically put into an else statement.</p>

</li>
<li><p>Nested if/elif/else statements are not allowed.</p>

</li>
<li><p>Function arguments or local variables must not be called <code class="code">RETURN_VALUE</code>, as this name is used internally.</p>

</li>
<li><p>Local variables must be assigned at most once (this includes function arguments, which are assigned at least once, namely when the function is called). An exception is made for "rapid reassignments": if the same variable is assigned and then reassigned immediately in the next statement, this only counts as a single assignment.</p>

</li>
<li><p>Since the compiler might change the order of statements, checking if a local variable (or list entry etc.) is bound is not safe.</p>

</li>
<li><p>For performance optimizations, the compiler might move expressions out of if/else statements, e.g. if they occur inside a (potentially expensive) <code class="code">List</code> call. Thus, code inside if/else statements must execute without error even if moved outside of the if/else statement.</p>

</li>
<li><p>Non-dense lists are not supported.</p>

</li>
</ul>
<p>Additionally, there is no detection for recursive function calls, so resolving such a function call leads to an infinite loop.</p>

<p><a id="X8307AD6B823FB122" name="X8307AD6B823FB122"></a></p>

<h4>1.4 <span class="Heading">Precompiling categories</span></h4>

<p>The main mode of application of the compiler is precompiling categories and storing the result in a file for later use via <code class="func">CapJitPrecompileCategory</code> (<a href="chap1_mj.html#X81627716853DCE40"><span class="RefLink">1.4-1</span></a>).</p>

<p><a id="X81627716853DCE40" name="X81627716853DCE40"></a></p>

<h5>1.4-1 CapJitPrecompileCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitPrecompileCategory</code>( <var class="Arg">category_constructor</var>, <var class="Arg">given_arguments</var>, <var class="Arg">package_name</var>, <var class="Arg">compiled_category_name</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Compiles operations of the CAP category returned by the function <var class="Arg">category_constructor</var> applied to <var class="Arg">given_arguments</var>. The result is available via a global function called <var class="Arg">compiled_category_name</var> which is written to the file <var class="Arg">package_name</var><code class="code">/precompiled_categories/</code><var class="Arg">compiled_category_name</var><code class="code">.gi</code>. The global function takes the same arguments as <var class="Arg">category_constructor</var> and returns the category with the compiled functions installed as primitive operations. If a list of operations is given via the option <code class="code">operations</code>, only operations in this list are precompiled. Else all installed operations (excluding operations which are part of suggested dependencies) of the category are precompiled. Furthermore, the options <code class="code">number_of_objectified_objects_in_data_structure_of_object</code>, <code class="code">number_of_objectified_morphisms_in_data_structure_of_object</code>, <code class="code">number_of_objectified_objects_in_data_structure_of_morphism</code>, and <code class="code">number_of_objectified_morphisms_in_data_structure_of_morphism</code> can optionally be set to allow the compiler to warn about about bad compilation results. For example, <code class="code">number_of_objectified_objects_in_data_structure_of_object</code> should be the number of calls to <code class="code">ObjectifyObjectForCAPWithAttributes</code> required for creating an object in the tower defined by <var class="Arg">category_constructor</var>, e.g. 1 if the tower has height one, or 2 if the tower has height two and the objects of the category at the top are given by objects in the category one level below. Warnings will be displayed if this number is exceeded (because this implies that not all wrap-unwrap-pairs could be canceled). Technical requirements:</p>


<ul>
<li><p><var class="Arg">category_constructor</var> must be a regular function, i.e. not an operation or a kernel function.</p>

</li>
<li><p><var class="Arg">category_constructor</var> must support the option <code class="code">FinalizeCategory</code>. WARNING: When using attributes you might run into errors because the options are only respected the first time you call the attribute getter. To catch such a situation, <var class="Arg">category_constructor</var> is applied to <var class="Arg">given_arguments</var> twice and if the results are identical (<code class="code">IsIdenticalObj</code>) an error is raised.</p>

</li>
<li><p>CAP operations returning <code class="code">fail</code> are excluded from the compilation because they usually do not fulfill all requirements of the compiler.</p>

</li>
</ul>
<p><a id="X819343157D62111A" name="X819343157D62111A"></a></p>

<h5>1.4-2 CapJitPrecompileCategoryAndCompareResult</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitPrecompileCategoryAndCompareResult</code>( <var class="Arg">category_constructor</var>, <var class="Arg">given_arguments</var>, <var class="Arg">package_name</var>, <var class="Arg">compiled_category_name</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Calls <code class="func">CapJitPrecompileCategory</code> (<a href="chap1_mj.html#X81627716853DCE40"><span class="RefLink">1.4-1</span></a>) with the given arguments and displays a warning if this changes the contents of <var class="Arg">package_name</var><code class="code">/precompiled_categories/</code><var class="Arg">compiled_category_name</var><code class="code">.gi</code>.</p>

<p><a id="X78F1B59B7DBEF671" name="X78F1B59B7DBEF671"></a></p>

<h4>1.5 <span class="Heading">Compiling a function manually</span></h4>

<p>One can also compile a function <code class="code">func</code> manually via <code class="func">CapJitCompiledFunction</code> (<a href="chap1_mj.html#X86F1D06C81670DC8"><span class="RefLink">1.5-2</span></a>).</p>

<p><a id="X87BAEADB78CC3FF0" name="X87BAEADB78CC3FF0"></a></p>

<h5>1.5-1 CapJitCompiledCAPOperationAsEnhancedSyntaxTree</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitCompiledCAPOperationAsEnhancedSyntaxTree</code>( <var class="Arg">cat</var>, <var class="Arg">operation_name</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>A special version of <code class="func">CapJitCompiledFunctionAsEnhancedSyntaxTree</code> (<a href="chap1_mj.html#X7B1445EE85D8CA0A"><span class="RefLink">1.5-3</span></a>) compiling the operation given by <var class="Arg">operation_name</var> in <var class="Arg">cat</var> (with post-processing disabled).</p>

<p><a id="X86F1D06C81670DC8" name="X86F1D06C81670DC8"></a></p>

<h5>1.5-2 CapJitCompiledFunction</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitCompiledFunction</code>( <var class="Arg">func</var>[, <var class="Arg">type_signature</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a function</p>

<p>Returns a compiled version of the function <var class="Arg">func</var> with signature <var class="Arg">type_signature</var> (see <code class="func">CapJitInferredDataTypes</code> (<a href="chap2_mj.html#X821BE2CE7C30674E"><span class="RefLink">2.5-9</span></a>)). If <var class="Arg">func</var> is an operation or a kernel function, it is returned unchanged. If <var class="Arg">type_signature</var> is not given, all steps which require knowledge about the types of variables are skipped. The type signature can also be given by three separate arguments: a CAP category, a list of input filters (as in <code class="code">filter_list</code> in the method name record) and an output filter (as in <code class="code">return_type</code> in the method name record). If a full type signature is not available but the first argument of <var class="Arg">func</var> is a CAP category, an instance of a CAP category can be given as the second argument. In this case, the category is used to get the type information required to resolve CAP operations.</p>

<p><a id="X7B1445EE85D8CA0A" name="X7B1445EE85D8CA0A"></a></p>

<h5>1.5-3 CapJitCompiledFunctionAsEnhancedSyntaxTree</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitCompiledFunctionAsEnhancedSyntaxTree</code>( <var class="Arg">func</var>, <var class="Arg">post_processing_enabled</var>[, <var class="Arg">type_signature</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a record</p>

<p>Like <code class="func">CapJitCompiledFunction</code> (<a href="chap1_mj.html#X86F1D06C81670DC8"><span class="RefLink">1.5-2</span></a>), but returns an enhanced syntax tree of the compiled function. <var class="Arg">func</var> must not be an operation or a kernel function because those cannot properly be represented as a syntax tree. The second argument can be used to disable post-processing, e.g. the application of compiler hints.</p>

<p><a id="X7E61259E7D6E8EEB" name="X7E61259E7D6E8EEB"></a></p>

<h4>1.6 <span class="Heading">Giving hints to the compiler</span></h4>

<p>You can give hints to the compiler to improve the result of the compilation. Compiler hints are attached to the category by making <code class="code">category!.compiler_hints</code> a record with one or more of the following keys:</p>


<ul>
<li><p><code class="code">category_attribute_names</code>: a list of names of attributes of the category. If a global variable in the compiled code has the same value (w.r.t. <code class="code">IsIdenticalObj</code>) as one of the given attributes of the category, the global variable is replaced by the attribute getter applied to the category. Background: During the compilation, the compiler resolves attributes occuring in the code and stores them in global variables called <code class="code">CAP_JIT_INTERNAL_GLOBAL_VARIABLE_n</code> (for integers <code class="code">n</code> starting from 1). If these variables cannot be replaced, the resulting code is only valid in the current session.</p>

</li>
<li><p><code class="code">source_and_range_attributes_from_morphism_attribute</code>: a record with keys <code class="code">object_attribute_name</code>, <code class="code">morphism_attribute_name</code>, <code class="code">source_attribute_getter_name</code>, and <code class="code">range_attribute_getter_name</code>. Replaces the attribute <code class="code">object_attribute_name</code> of the source (resp. range) of a morphism by <code class="code">source_attribute_getter_name</code> (resp. <code class="code">range_attribute_getter_name</code>) applied to the attribute <code class="code">morphism_attribute_name</code> of the morphism. Can be used if objects and morphisms can be easily created from the morphism datum anyway. Note: Some simple expressions like integers are NOT replaced.</p>

</li>
<li><p><code class="code">{category,object,morphism}_filter</code>: filters used for the data types of the category and its objects and morphisms.</p>

</li>
</ul>
<p>Note: The compiler can only discover the hints if the category is the first argument of the function.</p>

<p><a id="X7C1A71BB7DC16DDF" name="X7C1A71BB7DC16DDF"></a></p>

<h4>1.7 <span class="Heading">Stopping the compiler at a certain level</span></h4>

<p>You can use <code class="code">StopCompilationAtCategory</code> to prevent the compiler from inlining and optimizing code of a given category. You can revert this decision using <code class="code">ContinueCompilationAtCategory</code>.</p>

<p><a id="X85B3DF4C80406968" name="X85B3DF4C80406968"></a></p>

<h5>1.7-1 StopCompilationAtCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; StopCompilationAtCategory</code>( <var class="Arg">category</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Stops the compiler from inlining and optimizing code of <var class="Arg">category</var>.</p>

<p><a id="X7ECBAF2483705ED2" name="X7ECBAF2483705ED2"></a></p>

<h5>1.7-2 ContinueCompilationAtCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ContinueCompilationAtCategory</code>( <var class="Arg">category</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Allows the compiler to inline and optimize code of <var class="Arg">category</var> (this is the default).</p>

<p><a id="X80ABBF057E2687E1" name="X80ABBF057E2687E1"></a></p>

<h5>1.7-3 StopCompilationAtPrimitivelyInstalledOperationsOfCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; StopCompilationAtPrimitivelyInstalledOperationsOfCategory</code>( <var class="Arg">category</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Stops the compiler from inlining and optimizing code of primitively installed operations of <var class="Arg">category</var>. Warning: Due to caching of compiled CAP operations, this has to be called before any compilation involving <var class="Arg">category</var>.</p>

<p><a id="X86EE97ED7A87D7CC" name="X86EE97ED7A87D7CC"></a></p>

<h5>1.7-4 ContinueCompilationAtPrimitivelyInstalledOperationsOfCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ContinueCompilationAtPrimitivelyInstalledOperationsOfCategory</code>( <var class="Arg">category</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Allows the compiler to inline and optimize code of primitively installed operations of <var class="Arg">category</var> (this is the default).</p>

<p><a id="X7F76759D7D772538" name="X7F76759D7D772538"></a></p>

<h4>1.8 <span class="Heading">Disabling the automatic inference of data types</span></h4>

<p><a id="X843286607CD2DE7E" name="X843286607CD2DE7E"></a></p>

<h5>1.8-1 CapJitDisableDataTypeInference</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitDisableDataTypeInference</code>(  )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitEnableDataTypeInference</code>(  )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>In case of errors, the automatic inference of data types can be disabled (and re-enabled later on).</p>

<p><a id="X8517503D80444503" name="X8517503D80444503"></a></p>

<h4>1.9 <span class="Heading">Proof assistant mode</span></h4>

<p><a id="X795104B985A220EE" name="X795104B985A220EE"></a></p>

<h5>1.9-1 CapJitEnableProofAssistantMode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitEnableProofAssistantMode</code>(  )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitDisableProofAssistantMode</code>(  )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>(experimental) Enables or disables the (experimental) proof assistant mode. For example, in this mode the compiler will display warnings if the code involves CAP operations which are not known to be compatible with the congruence of morphisms, and expressions will not be hoisted or deduplicated.</p>

<p><a id="X7B946AD083F7CEEA" name="X7B946AD083F7CEEA"></a></p>

<h4>1.10 <span class="Heading">Getting information about the compilation process</span></h4>

<p>You can increase the info level of <code class="code">InfoCapJit</code> to get information about the compilation process.</p>

<p><a id="X8202365E84A044DC" name="X8202365E84A044DC"></a></p>

<h5>1.10-1 InfoCapJit</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InfoCapJit</code></td><td class="tdright">(&nbsp;info class&nbsp;)</td></tr></table></div>
<p>Info class used for info messsages of the CAP compiler.</p>

<p><a id="X780099B481AB3AB7" name="X780099B481AB3AB7"></a></p>

<h4>1.11 <span class="Heading">FAQ</span></h4>


<ul>
<li><p>Q: Where do the category attributes in the compiled code come from?</p>

</li>
</ul>
<p>A: During compilation, attributes of categories are <em>resolved</em>, that is, their values are stored in global variables without keeping track of which category they belong to. After the compilation, CompilerForCAP tries to replace those global variables again by attributes registered via <code class="code">category_attribute_names</code> to the current category (for details, see <a href="chap1_mj.html#X7E61259E7D6E8EEB"><span class="RefLink">1.6</span></a>). If some attributes of the current category are categories themselves, their attributes are also taken into account (recursively). In this case, if two categories <code class="code">cat1</code> and <code class="code">cat2</code> have attributes <code class="code">Attr1</code> and <code class="code">Attr2</code>, respectively, with the same value, it is undefined whether <code class="code">Attr1( cat1 )</code> or <code class="code">Attr2( cat2 )</code> will be used. So even if only <code class="code">Attr2( cat2 )</code> appeared in the original code, <code class="code">Attr1( cat1 )</code> might appear in the compiled code.</p>


<ul>
<li><p>Q: Why is my function not resolved?</p>

</li>
</ul>
<p>A: The function might be listed in <code class="code">CAP_JIT_NON_RESOLVABLE_GLOBAL_VARIABLE_NAMES</code> or it might be missing an annotation with the pragma <code class="code">CAP_JIT_RESOLVE_FUNCTION</code>. Additionally, a function can only be resolved if it appears as a global variable in the tree during the resolving phase of the compilation. That is, it must be referenced from a global variable from the beginning on, or after global variables are resolved by <code class="func">CapJitResolvedGlobalVariables</code> (<a href="chap2_mj.html#X7FD883BA85F7EBE5"><span class="RefLink">2.5-19</span></a>). Possibly you have adapt <code class="func">CapJitResolvedGlobalVariables</code> (<a href="chap2_mj.html#X7FD883BA85F7EBE5"><span class="RefLink">2.5-19</span></a>) to your setting.</p>


<ul>
<li><p>Q: Why is do I get the error "a local variable with name &lt;name&gt; is assigned more than once (not as a part of a rapid reassignment), this is not supported"?</p>

</li>
</ul>
<p>A: For reasons of correctness, variables cannot be inlined if a variable is assigned more than once in the body of a function (this includes function arguments which are assigned at least once, namely when the function is called). An exception is made for "rapid reassignments": if the same variable is assigned and then reassigned immediately in the next statement, this only counts as a single assignment.</p>


<ul>
<li><p>Q: Why do I get one of the following errors: "tree includes statements or expressions which indicate possible side effects", "tree contains an assignment of a higher variable with initial name &lt;name&gt;, this is not supported", or "tree contains for loop over non-local variable, this is not supported" ?</p>

</li>
</ul>
<p>A: We can only drop unused variables, inline variables, etc. if we assume that the code contains no side effects. Statements like STAT_PROCCALL or assignment to higher variables cause (or at least indicate) side effects, so continuing with the compilation would probably not lead to a correct result.</p>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap0_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap2_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
