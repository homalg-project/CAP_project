<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (GroupRepresentationsForCAP) - Chapter 1: Associators</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap1"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap0_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap2_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap1.html">[MathJax off]</a></p>
<p><a id="X7B34D0E6854E90C8" name="X7B34D0E6854E90C8"></a></p>
<div class="ChapSects"><a href="chap1_mj.html#X7B34D0E6854E90C8">1 <span class="Heading">Associators</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1_mj.html#X7DFB63A97E67C0A1">1.1 <span class="Heading">Introduction</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1_mj.html#X7F83DF528480AEA3">1.2 <span class="Heading">Quickstart</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1_mj.html#X79173095857DDF35">1.3 <span class="Heading">Read, Write, and Display</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X82AD8BFE7CD71CF8">1.3-1 WriteDatabaseKeysToFile</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X78E7A0607FB818BE">1.3-2 WriteRepresentationsDataToFile</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X8780F38B87251D36">1.3-3 WriteSkeletalFunctorDataToFile</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X85442CB57BE3D927">1.3-4 WriteAssociatorDataToFile</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7E654A2D8288EE8D">1.3-5 WriteAssociatorComputationToFiles</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X81C450B183A546BD">1.3-6 ReadDatabaseKeys</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X8033F59579C55D50">1.3-7 ReadRepresentationsData</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7A2842FF79F26B89">1.3-8 ReadSkeletalFunctorData</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1_mj.html#X7F88BD8685B4BC2F">1.4 <span class="Heading">Computing associators</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X811814DD856A3DE5">1.4-1 InitializeGroupData</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X8673FBD279303BE8">1.4-2 InitializeGroupData</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7E1E8F12800E4F0B">1.4-3 InitializeGroupDataDixon</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7884273785F92915">1.4-4 InitializeGroupDataDixon</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X81D8D6C37EA80C1D">1.4-5 InitializeGroupData</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X79A39A907B16E449">1.4-6 SkeletalFunctorTensorData</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X78D58CC87E70A79F">1.4-7 SkeletalFunctorTensorData</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X78F8FC02844F02BB">1.4-8 AssociatorDataFromSkeletalFunctorTensorData</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7FE191EA861E3BAC">1.4-9 AssociatorForSufficientlyManyTriples</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7FDB23367988AEBC">1.4-10 AssociatorForSufficientlyManyTriples</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7CEA66157E5B37B3">1.4-11 ComputeAssociator</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X85736F6C7BAC51AD">1.4-12 ComputeAssociator</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7983B35A79F316AA">1.4-13 ComputeAssociator</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1_mj.html#X805C42557996F58A">1.5 <span class="Heading">Technical functions</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7E1A851182C4625E">1.5-1 SetInfoLevelForAssociatorComputations</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7D047E3C818BF0E8">1.5-2 DefinedOverCyclotomicField</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X824B13667A220C10">1.5-3 GroupReperesentationByImages</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7CE98A958129F0D6">1.5-4 DiagonalizationTransformationOfBraiding</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X791E859A7F1FA65A">1.5-5 AffordAllIrreducibleRepresentations</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7BBC4B9C7A190987">1.5-6 AffordAllIrreducibleRepresentationsDixon</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X870E591680884ACA">1.5-7 DefaultFieldForListOfRepresentations</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X831713DE85223C62">1.5-8 RewriteMatrixInCyclotomicGenerator</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7AB4E8C07C9B113C">1.5-9 InternalHomToTensorProductAdjunctMorphismTemp</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X8609C1BF79A09379">1.5-10 HomalgMatrixAsString</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7E4458C07E3A6D0E">1.5-11 DataFromSkeletalFunctorTensorDataAsStringList</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X84D9D02B7D050F0A">1.5-12 AsVectorSpaceMorphism</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X87E56E187C2D53A7">1.5-13 CreateEndomorphismFromString</a></span>
</div></div>
</div>

<h3>1 <span class="Heading">Associators</span></h3>

<p><a id="X7DFB63A97E67C0A1" name="X7DFB63A97E67C0A1"></a></p>

<h4>1.1 <span class="Heading">Introduction</span></h4>

<p>Let <span class="SimpleMath">\(G\)</span> be a finite group and let <span class="SimpleMath">\(G\)</span>-mod be a skeletal version of the monoidal category of finite dimensional complex representations of <span class="SimpleMath">\(G\)</span>. The purpose of these GAP methods is the computation of the associators of <span class="SimpleMath">\(G\)</span>-mod.</p>

<p><a id="X7F83DF528480AEA3" name="X7F83DF528480AEA3"></a></p>

<h4>1.2 <span class="Heading">Quickstart</span></h4>

<p>The following commands compute the associator of <span class="SimpleMath">\(D_8\)</span> and write all data necessary for the reproducibility of the computation to files with the prefix "D8".</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := DihedralGroup( 8 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ComputeAssociator( G, true, true, false );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">path := Filename( DirectoryTemporary( ), "D8" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">WriteAssociatorComputationToFiles( path );</span>
</pre></div>

<p><a id="X79173095857DDF35" name="X79173095857DDF35"></a></p>

<h4>1.3 <span class="Heading">Read, Write, and Display</span></h4>

<p>The following intermediate steps of the associator computation can be read from/written to files.</p>


<ul>
<li><p>Irreducible representations of a finite group given by matrices (Data 1).</p>

</li>
<li><p>Decomposition isomorphisms of tensor products into direct sums of irreducibles (Data 2).</p>

</li>
</ul>
<p>Furthermore, the following data can be written to files.</p>


<ul>
<li><p>A database key for the AssociatorsDatabase/DatabaseKeys.g file.</p>

</li>
<li><p>The final result, namely the associator (Data 3).</p>

</li>
</ul>
<p>Data 1 and Data 2 involve choices and thus are subject to changes in further versions of this package. However, the process Data 2 -&gt; Data 3 is a mathematical function and thus stable. For reproducibility, it is recommended to store all three data. To facilitate this task, use the function WriteAssociatorComputationToFiles.</p>

<p><a id="X82AD8BFE7CD71CF8" name="X82AD8BFE7CD71CF8"></a></p>

<h5>1.3-1 WriteDatabaseKeysToFile</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WriteDatabaseKeysToFile</code>( <var class="Arg">s</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: nothing</p>

<p>The argument is a filename <span class="SimpleMath">\(s\)</span>. This operation writes the database keys computed by the last call of InitializeGroupData to the corresponding file.</p>

<p><a id="X78E7A0607FB818BE" name="X78E7A0607FB818BE"></a></p>

<h5>1.3-2 WriteRepresentationsDataToFile</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WriteRepresentationsDataToFile</code>( <var class="Arg">s</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: nothing</p>

<p>The argument is a filename <span class="SimpleMath">\(s\)</span>. This operation writes the representations computed by the last call of InitializeGroupData to the corresponding file.</p>

<p><a id="X8780F38B87251D36" name="X8780F38B87251D36"></a></p>

<h5>1.3-3 WriteSkeletalFunctorDataToFile</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WriteSkeletalFunctorDataToFile</code>( <var class="Arg">s</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: nothing</p>

<p>The argument is a filename <span class="SimpleMath">\(s\)</span>. This operation writes the skeletal functor data computed by the last call of SkeletalFunctorTensorData to the corresponding file.</p>

<p><a id="X85442CB57BE3D927" name="X85442CB57BE3D927"></a></p>

<h5>1.3-4 WriteAssociatorDataToFile</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WriteAssociatorDataToFile</code>( <var class="Arg">s</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: nothing</p>

<p>The argument is a filename <span class="SimpleMath">\(s\)</span>. This operation writes the associator data of the initialized group to the corresponding file. You have to call AssociatorForSufficientlyManyTriples first.</p>

<p><a id="X7E654A2D8288EE8D" name="X7E654A2D8288EE8D"></a></p>

<h5>1.3-5 WriteAssociatorComputationToFiles</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WriteAssociatorComputationToFiles</code>( <var class="Arg">s</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: nothing</p>

<p>Only call this function if you did a whole associator computation first (e.g. using ComputeAssociator). The argument is a string <span class="SimpleMath">\(s\)</span>. This function writes 4 files:</p>


<ul>
<li><p><span class="SimpleMath">\(s\)</span>Key.g: A file for the database key of the associator computation.</p>

</li>
<li><p><span class="SimpleMath">\(s\)</span>Reps.g: A file containing the irreducible representations used for the associator computation.</p>

</li>
<li><p><span class="SimpleMath">\(s\)</span>Dec.g: A file for the tensor decompositions used for the associator computation.</p>

</li>
<li><p><span class="SimpleMath">\(s\)</span>Ass.g or <span class="SimpleMath">\(s\)</span>AssD.g: A file containing the computed associator. The suffix <span class="SimpleMath">\(D\)</span> is used if the associator was not computed for all triples.</p>

</li>
</ul>
<p><a id="X81C450B183A546BD" name="X81C450B183A546BD"></a></p>

<h5>1.3-6 ReadDatabaseKeys</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ReadDatabaseKeys</code>( <var class="Arg">s</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a list</p>

<p>The argument is a filename <span class="SimpleMath">\(s\)</span> of a file written by WriteDatabaseKeysToFile. The output is a list [ group, conductor, position of trivial character, field, category ].</p>

<p><a id="X8033F59579C55D50" name="X8033F59579C55D50"></a></p>

<h5>1.3-7 ReadRepresentationsData</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ReadRepresentationsData</code>( <var class="Arg">s_1</var>, <var class="Arg">s_2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a list</p>

<p>The arguments are a filename <span class="SimpleMath">\(s_1\)</span> of a file written by WriteDatabaseKeysToFile, and a filename <span class="SimpleMath">\(s_2\)</span> of a file written by WriteRepresentationsDataToFile. The output is a list [ ,number of irreducibles, irreducibles, representations given by images of generators, inverses of these images, vector space objects for the irreducibles ].</p>

<p><a id="X7A2842FF79F26B89" name="X7A2842FF79F26B89"></a></p>

<h5>1.3-8 ReadSkeletalFunctorData</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ReadSkeletalFunctorData</code>( <var class="Arg">s_1</var>, <var class="Arg">s_2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a list</p>

<p>The arguments are a filename <span class="SimpleMath">\(s_1\)</span> of a file written by WriteDatabaseKeysToFile, and a filename <span class="SimpleMath">\(s_2\)</span> of a file written by WriteSkeletalFunctorDataToFile. The output is a list [ irreducibles, skeletal functor tensor data, vector space objects for the irreducibles ].</p>

<p><a id="X7F88BD8685B4BC2F" name="X7F88BD8685B4BC2F"></a></p>

<h4>1.4 <span class="Heading">Computing associators</span></h4>

<p><a id="X811814DD856A3DE5" name="X811814DD856A3DE5"></a></p>

<h5>1.4-1 InitializeGroupData</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InitializeGroupData</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a list</p>

<p>The argument is a group <span class="SimpleMath">\(G\)</span>. This method calls InitializeGroupData( G, false ).</p>

<p><a id="X8673FBD279303BE8" name="X8673FBD279303BE8"></a></p>

<h5>1.4-2 InitializeGroupData</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InitializeGroupData</code>( <var class="Arg">G</var>, <var class="Arg">b</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a list</p>

<p>The arguments are a group <span class="SimpleMath">\(G\)</span> and a boolean <span class="SimpleMath">\(b\)</span>. The output is a list [ generators of <span class="SimpleMath">\(G\)</span> ,number of irreducibles, irreducibles, representations given by images of generators, inverses of these images, vector space objects for the irreducibles ]. Furthermore, this method stores the database key, which can be written using WriteDatabaseKeysToFile. If <span class="SimpleMath">\(b\)</span> is true, then the id of the group in the database key is given by its string, otherwise it is given by its id in the SmallGroupLibrary.</p>

<p><a id="X7E1E8F12800E4F0B" name="X7E1E8F12800E4F0B"></a></p>

<h5>1.4-3 InitializeGroupDataDixon</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InitializeGroupDataDixon</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a list</p>

<p>The argument is a group <span class="SimpleMath">\(G\)</span>. This method calls InitializeGroupDataDixon( G, false ).</p>

<p><a id="X7884273785F92915" name="X7884273785F92915"></a></p>

<h5>1.4-4 InitializeGroupDataDixon</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InitializeGroupDataDixon</code>( <var class="Arg">G</var>, <var class="Arg">b</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a list</p>

<p>The arguments are a group <span class="SimpleMath">\(G\)</span> and a boolean <span class="SimpleMath">\(b\)</span>. This method does the same as InitializeGroupData, but uses IrreducibleRepresentationsDixon for affording irreducible representations.</p>

<p><a id="X81D8D6C37EA80C1D" name="X81D8D6C37EA80C1D"></a></p>

<h5>1.4-5 InitializeGroupData</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InitializeGroupData</code>( <var class="Arg">arg1</var>, <var class="Arg">arg2</var>, <var class="Arg">arg3</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p><a id="X79A39A907B16E449" name="X79A39A907B16E449"></a></p>

<h5>1.4-6 SkeletalFunctorTensorData</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SkeletalFunctorTensorData</code>(  )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a list</p>

<p>There is no argument. This methods calls SkeletalFunctorTensorData with the output of the last call of InitializeGroupData or InitializeGroupDataDixon.</p>

<p><a id="X78D58CC87E70A79F" name="X78D58CC87E70A79F"></a></p>

<h5>1.4-7 SkeletalFunctorTensorData</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SkeletalFunctorTensorData</code>( <var class="Arg">l</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a list</p>

<p>The argument is a list <span class="SimpleMath">\(l\)</span> which is the output of InitializeGroupData, InitializeGroupDataDixon, or ReadRepresentationsData. The output is a triple <span class="SimpleMath">\([t_1,t_2,t_3]\)</span>. <span class="SimpleMath">\(t_1\)</span> is the list of all characters of <span class="SimpleMath">\(G\)</span>. <span class="SimpleMath">\(t_2\)</span> is a list such that the <span class="SimpleMath">\((i,j)\)</span>-th entry, where <span class="SimpleMath">\(i,j\)</span> range from 1 to the number of irreducibles, is a pair of mutual inverse morphisms <span class="SimpleMath">\([\alpha, \alpha^{-1}]\)</span>, and <span class="SimpleMath">\(\alpha\)</span> is a decomposition isomorphism <span class="SimpleMath">\(\bigoplus_{\chi \in \mathrm{Irr}(G)}V_{\chi}^{n_{\chi}} \rightarrow V_i \otimes V_j\)</span>. <span class="SimpleMath">\(t_3\)</span> is a list of vector space objects for the irreducibles.</p>

<p><a id="X78F8FC02844F02BB" name="X78F8FC02844F02BB"></a></p>

<h5>1.4-8 AssociatorDataFromSkeletalFunctorTensorData</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AssociatorDataFromSkeletalFunctorTensorData</code>( <var class="Arg">a</var>, <var class="Arg">b</var>, <var class="Arg">c</var>, <var class="Arg">l</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a list</p>

<p>The arguments are integers <span class="SimpleMath">\(a,b,c\)</span> and a list <span class="SimpleMath">\(l\)</span> which is the output of SkeletalFunctorTensorData. The output is a list containing homalg matrices representing the components of the associator of <span class="SimpleMath">\(V_a, V_b, V_c\)</span>, where the numbers correspond to the enlisting of the irreducible characters given by <span class="SimpleMath">\(l\)</span>.</p>

<p><a id="X7FE191EA861E3BAC" name="X7FE191EA861E3BAC"></a></p>

<h5>1.4-9 AssociatorForSufficientlyManyTriples</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AssociatorForSufficientlyManyTriples</code>(  )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a list</p>

<p>There is no argument. This methods calls AssociatorForSufficientlyManyTriples with the output of the last call of SkeletalFunctorTensorData and false.</p>

<p><a id="X7FDB23367988AEBC" name="X7FDB23367988AEBC"></a></p>

<h5>1.4-10 AssociatorForSufficientlyManyTriples</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AssociatorForSufficientlyManyTriples</code>( <var class="Arg">l</var>, <var class="Arg">b</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a list</p>

<p>The arguments are a list <span class="SimpleMath">\(l\)</span> which is the output of SkeletalFunctorTensorData, and a boolean <span class="SimpleMath">\(b\)</span>. The output is a list of lists <span class="SimpleMath">\(L\)</span> such that <span class="SimpleMath">\(L[a][b][c]\)</span> contains the associator computed by AssociatorDataFromSkeletalFunctorTensorData(a,b,c). If <span class="SimpleMath">\(b\)</span> is true, then <span class="SimpleMath">\(a,b,c\)</span> ranges through all possible triples, otherwise, <span class="SimpleMath">\(a,b,c\)</span> are computed for so many triples such that the others can be obtained using braidings.</p>

<p><a id="X7CEA66157E5B37B3" name="X7CEA66157E5B37B3"></a></p>

<h5>1.4-11 ComputeAssociator</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ComputeAssociator</code>( <var class="Arg">G</var>, <var class="Arg">b_1</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a list</p>

<p>The arguments are a group <span class="SimpleMath">\(G\)</span>, and a boolean <span class="SimpleMath">\(b_1\)</span>. The output is ComputeAssociator( G, b_1, false, true ).</p>

<p><a id="X85736F6C7BAC51AD" name="X85736F6C7BAC51AD"></a></p>

<h5>1.4-12 ComputeAssociator</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ComputeAssociator</code>( <var class="Arg">G</var>, <var class="Arg">b_1</var>, <var class="Arg">b_2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a list</p>

<p>The arguments are a group <span class="SimpleMath">\(G\)</span>, and two booleans <span class="SimpleMath">\(b_1\)</span>, <span class="SimpleMath">\(b_2\)</span>. The output is ComputeAssociator( G, b_1, b_2, true ).</p>

<p><a id="X7983B35A79F316AA" name="X7983B35A79F316AA"></a></p>

<h5>1.4-13 ComputeAssociator</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ComputeAssociator</code>( <var class="Arg">G</var>, <var class="Arg">b_1</var>, <var class="Arg">b_2</var>, <var class="Arg">b_3</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a list</p>

<p>The arguments are a group <span class="SimpleMath">\(G\)</span>, and three booleans <span class="SimpleMath">\(b_1\)</span>, <span class="SimpleMath">\(b_2\)</span>, <span class="SimpleMath">\(b_3\)</span>. The output is a list <span class="SimpleMath">\(l\)</span> whose <span class="SimpleMath">\((a,b,c)\)</span>-th entry contains a string representing the associator of the objects <span class="SimpleMath">\(V_a, V_b, V_c\)</span> in a skeleton of the representation category of <span class="SimpleMath">\(G\)</span>, where <span class="SimpleMath">\(V_{\ast}\)</span> are irreducible representations corresponding to the ordering of the irreducible characters Irr(<span class="SimpleMath">\(G\)</span>). If <span class="SimpleMath">\(b_1\)</span> is true, this method uses IrreducibleRepresentationsDixon, otherwise it uses IrreducibleAffordingRepresentation. If <span class="SimpleMath">\(b_2\)</span> is true, the associators are computed for all possible triples <span class="SimpleMath">\(a,b,c\)</span>, otherwise only for sufficiently many such that the others can be reproduced using the braiding in the representation category. If <span class="SimpleMath">\(b_3\)</span> is true, then the id of the group in the database key is given by its string, otherwise it is given by its id in the SmallGroupLibrary. This last boolean is relevant only if you want to write the computed associators to files (e.g. using WriteAssociatorComputationToFiles).</p>

<p><a id="X805C42557996F58A" name="X805C42557996F58A"></a></p>

<h4>1.5 <span class="Heading">Technical functions</span></h4>

<p><a id="X7E1A851182C4625E" name="X7E1A851182C4625E"></a></p>

<h5>1.5-1 SetInfoLevelForAssociatorComputations</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SetInfoLevelForAssociatorComputations</code>( <var class="Arg">l</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: nothing</p>

<p>The argument is an integer <span class="SimpleMath">\(l\)</span>. If <span class="SimpleMath">\(l &gt; 0\)</span>, then the functions for computing associators provide information during the computation. This is useful in cases where the computation may take a long time.</p>

<p><a id="X7D047E3C818BF0E8" name="X7D047E3C818BF0E8"></a></p>

<h5>1.5-2 DefinedOverCyclotomicField</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DefinedOverCyclotomicField</code>( <var class="Arg">n</var>, <var class="Arg">f</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a boolean</p>

<p>The arguments are an integer <span class="SimpleMath">\(n\)</span> and a group homomorphism <span class="SimpleMath">\(f\)</span> whose images are matrices. The output is true if the entries of the images of <span class="SimpleMath">\(f\)</span> lie in a cyclotomic field generated by a primitive <span class="SimpleMath">\(n\)</span>-th root of unity, false otherwise.</p>

<p><a id="X824B13667A220C10" name="X824B13667A220C10"></a></p>

<h5>1.5-3 GroupReperesentationByImages</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GroupReperesentationByImages</code>( <var class="Arg">G</var>, <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a group homomorphism</p>

<p>The arguments are a group <span class="SimpleMath">\(G\)</span> with generators <span class="SimpleMath">\(g_1, \dots, g_n\)</span> and a list <span class="SimpleMath">\(L = [ l_1, \dots, l_n ]\)</span>. The output is the group homomorphism from <span class="SimpleMath">\(G\)</span> to the group generated by the elements of <span class="SimpleMath">\(L\)</span>, mapping <span class="SimpleMath">\(g_i\)</span> to <span class="SimpleMath">\(l_i\)</span>.</p>

<p><a id="X7CE98A958129F0D6" name="X7CE98A958129F0D6"></a></p>

<h5>1.5-4 DiagonalizationTransformationOfBraiding</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DiagonalizationTransformationOfBraiding</code>( <var class="Arg">e</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: an invertible endomorphism in <span class="SimpleMath">\(\mathrm{Hom}(V,V)\)</span></p>

<p>The argument is an endomorphism <span class="SimpleMath">\(e \in \mathrm{Hom}(V,V)\)</span> of vector spaces whose minimal polynomial divides <span class="SimpleMath">\(x^2 - 1\)</span>. The output is an invertible endomorphism <span class="SimpleMath">\(t\)</span> such that <span class="SimpleMath">\(t^{-1} \circ e \circ t\)</span> is a diagonal matrix.</p>

<p><a id="X791E859A7F1FA65A" name="X791E859A7F1FA65A"></a></p>

<h5>1.5-5 AffordAllIrreducibleRepresentations</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AffordAllIrreducibleRepresentations</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a list</p>

<p>The argument is a group <span class="SimpleMath">\(G\)</span>. The output is a list of all irreducible representations of <span class="SimpleMath">\(G\)</span> using the command IrreducibleAffordingRepresentation.</p>

<p><a id="X7BBC4B9C7A190987" name="X7BBC4B9C7A190987"></a></p>

<h5>1.5-6 AffordAllIrreducibleRepresentationsDixon</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AffordAllIrreducibleRepresentationsDixon</code>( <var class="Arg">G</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a list</p>

<p>The argument is a group <span class="SimpleMath">\(G\)</span>. The output is a list of all irreducible representations of <span class="SimpleMath">\(G\)</span> using the command IrreducibleRepresentationsDixon.</p>

<p><a id="X870E591680884ACA" name="X870E591680884ACA"></a></p>

<h5>1.5-7 DefaultFieldForListOfRepresentations</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DefaultFieldForListOfRepresentations</code>( <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a GAP field</p>

<p>The argument is a list <span class="SimpleMath">\(L\)</span> of representations of a group <span class="SimpleMath">\(G\)</span>. The output is a field over which all representations are defined simultaniously.</p>

<p><a id="X831713DE85223C62" name="X831713DE85223C62"></a></p>

<h5>1.5-8 RewriteMatrixInCyclotomicGenerator</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RewriteMatrixInCyclotomicGenerator</code>( <var class="Arg">M</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a matrix</p>

<p>The arguments are a matrix <span class="SimpleMath">\(M\)</span> and an integer <span class="SimpleMath">\(n\)</span>. The output is a matrix <span class="SimpleMath">\(N\)</span> in <span class="SimpleMath">\(Q[\epsilon]\)</span>. Substituting an <span class="SimpleMath">\(n\)</span>-th root of unity for <span class="SimpleMath">\(\epsilon\)</span> in <span class="SimpleMath">\(N\)</span> yields <span class="SimpleMath">\(M\)</span>.</p>

<p><a id="X7AB4E8C07C9B113C" name="X7AB4E8C07C9B113C"></a></p>

<h5>1.5-9 InternalHomToTensorProductAdjunctMorphismTemp</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InternalHomToTensorProductAdjunctMorphismTemp</code>( <var class="Arg">b</var>, <var class="Arg">c</var>, <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a morphism in <span class="SimpleMath">\(\mathrm{Hom}(a \otimes b, c)\)</span>.</p>

<p>The arguments are objects <span class="SimpleMath">\(b,c\)</span> and a morphism <span class="SimpleMath">\(g: a \rightarrow \mathrm{\underline{Hom}}(b,c)\)</span>. The output is a morphism <span class="SimpleMath">\(f: a \otimes b \rightarrow c\)</span> corresponding to <span class="SimpleMath">\(g\)</span> under the tensor hom adjunction.</p>

<p><a id="X8609C1BF79A09379" name="X8609C1BF79A09379"></a></p>

<h5>1.5-10 HomalgMatrixAsString</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HomalgMatrixAsString</code>( <var class="Arg">M</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a string</p>

<p>The argument is a homalg matrx <span class="SimpleMath">\(M\)</span>. The output is a string consisting of the elements of <span class="SimpleMath">\(M\)</span>, seperated by commas.</p>

<p><a id="X7E4458C07E3A6D0E" name="X7E4458C07E3A6D0E"></a></p>

<h5>1.5-11 DataFromSkeletalFunctorTensorDataAsStringList</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DataFromSkeletalFunctorTensorDataAsStringList</code>( <var class="Arg">l</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a list of strings and empty entries</p>

<p>The argument is a list <span class="SimpleMath">\(l\)</span> of homalg matrices. In <span class="SimpleMath">\(l\)</span>, empty entries are allowed. The output is a list where each non-empty entry of <span class="SimpleMath">\(l\)</span> is converted to a string using HomalgMatrixAsString.</p>

<p><a id="X84D9D02B7D050F0A" name="X84D9D02B7D050F0A"></a></p>

<h5>1.5-12 AsVectorSpaceMorphism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AsVectorSpaceMorphism</code>( <var class="Arg">M</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a vector space morphism</p>

<p>The argument is a homalg matrix <span class="SimpleMath">\(M\)</span>. The output is a vector space morphism whose underlying matrix is given by <span class="SimpleMath">\(M\)</span>.</p>

<p><a id="X87E56E187C2D53A7" name="X87E56E187C2D53A7"></a></p>

<h5>1.5-13 CreateEndomorphismFromString</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CreateEndomorphismFromString</code>( <var class="Arg">V</var>, <var class="Arg">s</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a vector space morphism</p>

<p>The arguments are a vector space object <span class="SimpleMath">\(V\)</span> and a string <span class="SimpleMath">\(s\)</span> consisting of <span class="SimpleMath">\(\mathrm{dim}(V)^2\)</span> elements of the ground field of <span class="SimpleMath">\(V\)</span>. The output is a vector space endomorphism <span class="SimpleMath">\(V \rightarrow V\)</span> defined by <span class="SimpleMath">\(s\)</span>.</p>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap0_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap2_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
