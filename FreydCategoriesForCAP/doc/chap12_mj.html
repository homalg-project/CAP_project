<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (FreydCategoriesForCAP) - Chapter 12: Examples and Tests</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap12"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chap10_mj.html">10</a>  <a href="chap11_mj.html">11</a>  <a href="chap12_mj.html">12</a>  <a href="chap13_mj.html">13</a>  <a href="chap14_mj.html">14</a>  <a href="chap15_mj.html">15</a>  <a href="chap16_mj.html">16</a>  <a href="chap17_mj.html">17</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap11_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap13_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap12.html">[MathJax off]</a></p>
<p><a id="X7967FE8E7BBDF485" name="X7967FE8E7BBDF485"></a></p>
<div class="ChapSects"><a href="chap12_mj.html#X7967FE8E7BBDF485">12 <span class="Heading">Examples and Tests</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap12_mj.html#X816168F27A34BC10">12.1 <span class="Heading">Adelman category basics for category of rows</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap12_mj.html#X7F10D27C8668C8FF">12.2 <span class="Heading">Adelman category basics for category of columns</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap12_mj.html#X800F00FC80F05442">12.3 <span class="Heading">Basics based on category of rows</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap12_mj.html#X825D413F7D891B06">12.4 <span class="Heading">Basics based on category of columns</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap12_mj.html#X7C2B2E197863A2B5">12.5 <span class="Heading">CoFreyd category</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap12_mj.html#X82E68586814D020C">12.6 <span class="Heading">Cokernel image closure in category of rows</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap12_mj.html#X7FF5A0D086602294">12.7 <span class="Heading">Cokernel image closure in category of columns</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap12_mj.html#X839428D58152A999">12.8 <span class="Heading">Adelman category basics</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap12_mj.html#X85F769C5823FAD20">12.9 <span class="Heading">Grade filtration</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap12_mj.html#X7E4FE96D7AD5A312">12.10 <span class="Heading">Homomorphisms between f.p. functors based on category of rows</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap12_mj.html#X87D4D7857F0B6568">12.11 <span class="Heading">Homomorphisms between f.p. functors based on category of columns</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap12_mj.html#X84C669D87B0599DB">12.12 <span class="Heading">Linear closure of categories</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap12_mj.html#X81E7031D85FD2569">12.13 <span class="Heading">Matrices over ZP K</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap12_mj.html#X7F1E3F5A7EC538B6">12.14 <span class="Heading">Matrices over ZG</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap12_mj.html#X820CD9B28165BF9F">12.15 <span class="Heading">Testing if an object is projective, injective, bijective, and computing projective/injective dimensions</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap12_mj.html#X7AFC8F247C00D608">12.16 <span class="Heading">Prosets</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap12_mj.html#X789E61CF843CF960">12.17 <span class="Heading">Category of relations</span></a>
</span>
</div>
</div>

<h3>12 <span class="Heading">Examples and Tests</span></h3>

<p><a id="X816168F27A34BC10" name="X816168F27A34BC10"></a></p>

<h4>12.1 <span class="Heading">Adelman category basics for category of rows</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := HomalgRingOfIntegers();;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rows := CategoryOfRows( R );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">adelman := AdelmanCategory( rows );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj1 := CategoryOfRowsObject( 1, rows );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj2 := CategoryOfRowsObject( 2, rows );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">id := IdentityMorphism( obj2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := CategoryOfRowsMorphism( obj1, HomalgMatrix( [ [ 1, 2 ] ], 1, 2, R ), obj2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">beta := CategoryOfRowsMorphism( obj2, HomalgMatrix( [ [ 1, 2 ], [ 3, 4 ] ], 2, 2, R ), obj2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gamma := CategoryOfRowsMorphism( obj2, HomalgMatrix( [ [ 1, 3 ], [ 3, 4 ] ], 2, 2, R ), obj2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj1_a := AsAdelmanCategoryObject( obj1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj2_a := AsAdelmanCategoryObject( obj2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := AsAdelmanCategoryMorphism( beta );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">n := AsAdelmanCategoryMorphism( gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( m );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># backwards compatibility</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">IsIdenticalObj( MorphismDatum( m ), beta );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( PreCompose( m, n ), PreCompose( n, m ) );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( SubtractionForMorphisms( m, m ), ZeroMorphism( obj2_a, obj2_a ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( ZeroObjectFunctorial( adelman ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                         PreCompose( UniversalMorphismFromZeroObject( obj1_a), UniversalMorphismIntoZeroObject( obj1_a ) ) </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                        );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d := [ obj1_a, obj2_a ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi1 := ProjectionInFactorOfDirectSum( d, 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi2 := ProjectionInFactorOfDirectSum( d, 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">id := IdentityMorphism( DirectSum( d ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iota1 := InjectionOfCofactorOfDirectSum( d, 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iota2 := InjectionOfCofactorOfDirectSum( d, 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( PreCompose( pi1, iota1 ) + PreCompose( pi2, iota2 ), id );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( UniversalMorphismIntoDirectSum( d, [ pi1, pi2 ] ), id );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( UniversalMorphismFromDirectSum( d, [ iota1, iota2 ] ), id );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c := CokernelProjection( m );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c2 := CokernelProjection( c );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( c2, ZeroMorphism( Source( c2 ), Range( c2 ) ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( CokernelProjection( m ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( CokernelColift( m, CokernelProjection( m ) ), IdentityMorphism( CokernelObject( m ) ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">k := KernelEmbedding( c );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForMorphisms( PreCompose( k, c ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( KernelLift( m, KernelEmbedding( m ) ), IdentityMorphism( KernelObject( m ) ) );</span>
true
</pre></div>

<p><a id="X7F10D27C8668C8FF" name="X7F10D27C8668C8FF"></a></p>

<h4>12.2 <span class="Heading">Adelman category basics for category of columns</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := HomalgRingOfIntegers();;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cols := CategoryOfColumns( R );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">adelman := AdelmanCategory( cols );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj1 := CategoryOfColumnsObject( 1, cols );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj2 := CategoryOfColumnsObject( 2, cols );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">id := IdentityMorphism( obj2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := CategoryOfColumnsMorphism( obj1, HomalgMatrix( [ [ 1 ], [ 2 ] ], 2, 1, R ), obj2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">beta := CategoryOfColumnsMorphism( obj2, HomalgMatrix( [ [ 1, 3 ], [ 2, 4 ] ], 2, 2, R ), obj2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gamma := CategoryOfColumnsMorphism( obj2, HomalgMatrix( [ [ 1, 3 ], [ 3, 4 ] ], 2, 2, R ), obj2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj1_a := AsAdelmanCategoryObject( obj1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj2_a := AsAdelmanCategoryObject( obj2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := AsAdelmanCategoryMorphism( beta );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">n := AsAdelmanCategoryMorphism( gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( m );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( PreCompose( m, n ), PreCompose( n, m ) );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( SubtractionForMorphisms( m, m ), ZeroMorphism( obj2_a, obj2_a ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( ZeroObjectFunctorial( adelman ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                         PreCompose( UniversalMorphismFromZeroObject( obj1_a), UniversalMorphismIntoZeroObject( obj1_a ) ) </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                        );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d := [ obj1_a, obj2_a ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi1 := ProjectionInFactorOfDirectSum( d, 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi2 := ProjectionInFactorOfDirectSum( d, 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">id := IdentityMorphism( DirectSum( d ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iota1 := InjectionOfCofactorOfDirectSum( d, 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iota2 := InjectionOfCofactorOfDirectSum( d, 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( PreCompose( pi1, iota1 ) + PreCompose( pi2, iota2 ), id );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( UniversalMorphismIntoDirectSum( d, [ pi1, pi2 ] ), id );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( UniversalMorphismFromDirectSum( d, [ iota1, iota2 ] ), id );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c := CokernelProjection( m );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c2 := CokernelProjection( c );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( c2, ZeroMorphism( Source( c2 ), Range( c2 ) ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( CokernelProjection( m ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( CokernelColift( m, CokernelProjection( m ) ), IdentityMorphism( CokernelObject( m ) ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">k := KernelEmbedding( c );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForMorphisms( PreCompose( k, c ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( KernelLift( m, KernelEmbedding( m ) ), IdentityMorphism( KernelObject( m ) ) );</span>
true
</pre></div>

<p><a id="X800F00FC80F05442" name="X800F00FC80F05442"></a></p>

<h4>12.3 <span class="Heading">Basics based on category of rows</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "FreydCategoriesForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "RingsForHomalg", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := HomalgRingOfIntegers();;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cat := CategoryOfRows( R );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj1 := CategoryOfRowsObject( 1, cat );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj2 := CategoryOfRowsObject( 2, cat );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gamma := CategoryOfRowsMorphism( obj2, HomalgMatrix( [ [ 1, 1 ], [ 1, 1 ] ], 2, 2, R ), obj2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">## Freyd categories</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">freyd := FreydCategory( cat );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsAbelianCategory( freyd );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj_gamma := FreydCategoryObject( gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := RandomMorphismWithFixedSource( obj_gamma, [ [5], [5] ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( u ) and IsEqualForObjects( Source(u), obj_gamma );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := RandomMorphismWithFixedSource( obj_gamma, 5 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( u ) and IsEqualForObjects( Source(u), obj_gamma );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := RandomMorphismWithFixedRange( obj_gamma, [ [5], [5] ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( u ) and IsEqualForObjects( Range(u), obj_gamma );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := RandomMorphismWithFixedRange( obj_gamma, 5 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( u ) and IsEqualForObjects( Range(u), obj_gamma );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj_delta := RandomObject( freyd, [[10],[10],[10]] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj_delta := RandomObject( freyd, 10 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := RandomMorphismWithFixedSourceAndRange( obj_gamma, obj_delta, [ 5 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( u );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForObjects( Source(u), obj_gamma ) and IsEqualForObjects( Range(u), obj_delta );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := RandomMorphismWithFixedSourceAndRange( obj_gamma, obj_delta, 5 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( u );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForObjects( Source(u), obj_gamma ) and IsEqualForObjects( Range(u), obj_delta );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( RandomMorphism( freyd, 5 ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( RandomMorphism( freyd, [[[5],[5],[5]],[[5],[5],[5]],[1]] ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := FreydCategoryMorphism( obj_gamma, gamma, obj_gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">witness := MorphismWitness( f );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := FreydCategoryMorphism( obj_gamma, ZeroMorphism( obj2, obj2 ), obj_gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( f, g );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c := PreCompose( f, f );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s := g + g;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := CategoryOfRowsMorphism( obj1, HomalgMatrix( [ [ 2 ] ], 1, 1, R ), obj1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Z2 := FreydCategoryObject( a );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">id := IdentityMorphism( Z2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">z := id + id + id;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d := DirectSumFunctorial( [ z, z, z ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pr2 := ProjectionInFactorOfDirectSum( [ Z2, Z2, Z2 ], 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pr3 := ProjectionInFactorOfDirectSum( [ Z2, Z2, Z2 ], 3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UniversalMorphismIntoDirectSum( [ pr3, pr2 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inj1 := InjectionOfCofactorOfDirectSum( [ Z2, Z2, Z2 ], 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inj2 := InjectionOfCofactorOfDirectSum( [ Z2, Z2, Z2 ], 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UniversalMorphismFromDirectSum( [ inj2, inj1 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ZFree := obj1/freyd;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">id := IdentityMorphism( ZFree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">z := id + id;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CokernelProjection( z );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CokernelColift( z, CokernelProjection( z ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UniversalMorphismFromZeroObjectWithGivenZeroObject( obj_gamma, ZeroObject( freyd ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MultiplyWithElementOfCommutativeRingForMorphisms( 2 / R, f );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := HomalgFieldOfRationalsInSingular() * "x,y,z";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Rows_S := CategoryOfRows( S );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S3 := CategoryOfRowsObject( 3, Rows_S );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S1 := CategoryOfRowsObject( 1, Rows_S );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mor := CategoryOfRowsMorphism( S3, HomalgMatrix( "[x,y,z]", 3, 1, S ), S1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">k := FreydCategoryObject( mor );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">w := EpimorphismFromSomeProjectiveObjectForKernelObject( UniversalMorphismIntoZeroObject( k ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">k := KernelEmbedding( w );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ColiftAlongEpimorphism( CokernelProjection( k ), CokernelProjection( k ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">## Homomorphism structures</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Z4 := FreydCategoryObject( AsCategoryOfRowsMorphism( HomalgMatrix( "[4]", 1, 1, R ), cat ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Z3 := FreydCategoryObject( AsCategoryOfRowsMorphism( HomalgMatrix( "[3]", 1, 1, R ), cat ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HomomorphismStructureOnObjects( Z4, Z2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HomomorphismStructureOnObjects( Z4, Z4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HomomorphismStructureOnObjects( Z2, Z4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HomomorphismStructureOnObjects( Z3, Z4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HomomorphismStructureOnMorphisms( IdentityMorphism( DirectSum( Z4, Z2, Z3 ) ), -IdentityMorphism( DirectSum( Z4, Z3 ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">## Lifts</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">S2 := CategoryOfRowsObject( 2, Rows_S );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S4 := CategoryOfRowsObject( 4, Rows_S );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S1_freyd := AsFreydCategoryObject( S1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S2_freyd := AsFreydCategoryObject( S2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S3_freyd := AsFreydCategoryObject( S3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S4_freyd := AsFreydCategoryObject( S4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lift := FreydCategoryMorphism( S1_freyd, CategoryOfRowsMorphism( S1, HomalgMatrix( "[x]", 1, 1, S ), S1 ), S1_freyd );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gamma := FreydCategoryMorphism( S1_freyd, CategoryOfRowsMorphism( S1, HomalgMatrix( "[y]", 1,1, S ), S1 ), S1_freyd );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := PreCompose( lift, gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLiftable( alpha, gamma );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Lift( alpha, gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsColiftable( lift, alpha );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( PreCompose( lift, Colift( lift, alpha ) ), alpha );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lift := FreydCategoryMorphism( S2_freyd, CategoryOfRowsMorphism( S2, HomalgMatrix( "[x,y,z,x^2,1,z+1]", 2, 3, S ), S3 ), S3_freyd );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gamma := FreydCategoryMorphism( S3_freyd, CategoryOfRowsMorphism( S3, HomalgMatrix( "[x,y,z,z+1, x^2,y^2,z^2,z^2+1, x^3,y^3,z^3,z^3+1]", 3,4, S ), S4 ), S4_freyd );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := PreCompose( lift, gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Lift( alpha, gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Colift( lift, alpha );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( PreCompose( lift, Colift( lift, alpha ) ), alpha );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">interpretation := InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( gamma,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">InterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( Source( gamma ), Range( gamma ), interpretation ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">## Opposite</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">HomomorphismStructureOnObjects( Opposite( Z4 ), Opposite( Z2 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HomomorphismStructureOnObjects( Z2, Z4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">interpretation := InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( Opposite( gamma ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( Opposite( gamma ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">InterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( Source( Opposite( gamma ) ), Range( Opposite( gamma ) ), interpretation ) );</span>
true
</pre></div>

<p><a id="X825D413F7D891B06" name="X825D413F7D891B06"></a></p>

<h4>12.4 <span class="Heading">Basics based on category of columns</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := HomalgRingOfIntegers();;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cat := CategoryOfColumns( R );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj1 := CategoryOfColumnsObject( 1, cat );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj2 := CategoryOfColumnsObject( 2, cat );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gamma := CategoryOfColumnsMorphism( obj2, HomalgMatrix( [ [ 1, 1 ], [ 1, 1 ] ], 2, 2, R ), obj2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">## Freyd categories</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">freyd := FreydCategory( cat );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsAbelianCategory( freyd );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj_gamma := FreydCategoryObject( gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := FreydCategoryMorphism( obj_gamma, gamma, obj_gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">witness := MorphismWitness( f );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := FreydCategoryMorphism( obj_gamma, ZeroMorphism( obj2, obj2 ), obj_gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( f, g );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c := PreCompose( f, f );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s := g + g;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := CategoryOfColumnsMorphism( obj1, HomalgMatrix( [ [ 2 ] ], 1, 1, R ), obj1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Z2 := FreydCategoryObject( a );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">id := IdentityMorphism( Z2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">z := id + id + id;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d := DirectSumFunctorial( [ z, z, z ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pr2 := ProjectionInFactorOfDirectSum( [ Z2, Z2, Z2 ], 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pr3 := ProjectionInFactorOfDirectSum( [ Z2, Z2, Z2 ], 3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UniversalMorphismIntoDirectSum( [ pr3, pr2 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inj1 := InjectionOfCofactorOfDirectSum( [ Z2, Z2, Z2 ], 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inj2 := InjectionOfCofactorOfDirectSum( [ Z2, Z2, Z2 ], 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UniversalMorphismFromDirectSum( [ inj2, inj1 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ZFree := AsFreydCategoryObject( obj1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">id := IdentityMorphism( ZFree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">z := id + id;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CokernelProjection( z );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CokernelColift( z, CokernelProjection( z ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := HomalgFieldOfRationalsInSingular() * "x,y,z";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Cols_S := CategoryOfColumns( S );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S3 := CategoryOfColumnsObject( 3, Cols_S );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S1 := CategoryOfColumnsObject( 1, Cols_S );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mor := CategoryOfColumnsMorphism( S3, HomalgMatrix( "[x,y,z]", 1, 3, S ), S1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">k := FreydCategoryObject( mor );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">w := EpimorphismFromSomeProjectiveObjectForKernelObject( UniversalMorphismIntoZeroObject( k ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">k := KernelEmbedding( w );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ColiftAlongEpimorphism( CokernelProjection( k ), CokernelProjection( k ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">## Homomorphism structures</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Z4 := FreydCategoryObject( AsCategoryOfColumnsMorphism( HomalgMatrix( "[4]", 1, 1, R ), cat ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Z3 := FreydCategoryObject( AsCategoryOfColumnsMorphism( HomalgMatrix( "[3]", 1, 1, R ), cat ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HomomorphismStructureOnObjects( Z4, Z2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HomomorphismStructureOnObjects( Z4, Z4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HomomorphismStructureOnObjects( Z2, Z4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HomomorphismStructureOnObjects( Z3, Z4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HomomorphismStructureOnMorphisms( IdentityMorphism( DirectSum( Z4, Z2, Z3 ) ), -IdentityMorphism( DirectSum( Z4, Z3 ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">## Lifts</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">S2 := CategoryOfColumnsObject( 2, Cols_S );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S4 := CategoryOfColumnsObject( 4, Cols_S );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S1_freyd := AsFreydCategoryObject( S1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S2_freyd := AsFreydCategoryObject( S2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S3_freyd := AsFreydCategoryObject( S3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S4_freyd := AsFreydCategoryObject( S4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lift := FreydCategoryMorphism( S1_freyd, CategoryOfColumnsMorphism( S1, HomalgMatrix( "[x]", 1, 1, S ), S1 ), S1_freyd );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gamma := FreydCategoryMorphism( S1_freyd, CategoryOfColumnsMorphism( S1, HomalgMatrix( "[y]", 1,1, S ), S1 ), S1_freyd );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := PreCompose( lift, gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Lift( alpha, gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Colift( lift, alpha );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( PreCompose( lift, Colift( lift, alpha ) ), alpha );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lift := FreydCategoryMorphism( S2_freyd, CategoryOfColumnsMorphism( S2, HomalgMatrix( "[x,y,z,x^2,1,z+1]", 3, 2, S ), S3 ), S3_freyd );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gamma := FreydCategoryMorphism( S3_freyd, CategoryOfColumnsMorphism( S3, HomalgMatrix( "[x,y,z,z+1, x^2,y^2,z^2,z^2+1, x^3,y^3,z^3,z^3+1]", 4,3, S ), S4 ), S4_freyd );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := PreCompose( lift, gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Lift( alpha, gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Colift( lift, alpha );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( PreCompose( lift, Colift( lift, alpha ) ), alpha );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">interpretation := InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( gamma,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">InterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( Source( gamma ), Range( gamma ), interpretation ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">## Opposite</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">HomomorphismStructureOnObjects( Opposite( Z4 ), Opposite( Z2 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HomomorphismStructureOnObjects( Z2, Z4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">interpretation := InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( Opposite( gamma ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( Opposite( gamma ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">InterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( Source( Opposite( gamma ) ), Range( Opposite( gamma ) ), interpretation ) );</span>
true
</pre></div>

<p><a id="X7C2B2E197863A2B5" name="X7C2B2E197863A2B5"></a></p>

<h4>12.5 <span class="Heading">CoFreyd category</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "FreydCategoriesForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ZZZ := HomalgRingOfIntegers( );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rows := CategoryOfRows( ZZZ );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">co_freyd := CoFreydCategory( rows );</span>
CoFreyd( Rows( Z ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rows_obj := CategoryOfRowsObject( rows, 1 );; # ZZZ^1</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">co_freyd_obj := AsCoFreydCategoryObject( rows_obj );; # ZZZ^1 -&gt; 0</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rows_mor := CategoryOfRowsMorphism( rows, rows_obj, HomalgMatrix( [ 2 ], 1, 1, ZZZ ), rows_obj );; # ZZZ^1 --2-&gt; ZZZ^1</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">co_freyd_mor := CoFreydCategoryMorphism( co_freyd_obj, rows_mor, co_freyd_obj );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( co_freyd_mor );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( KernelObject( co_freyd_mor ) );</span>

--------------------------------
CoRelation morphism:
--------------------------------

Source: 
A row module over Z of rank 1

Matrix: 
[ [  2 ] ]

Range: 
A row module over Z of rank 1

A morphism in Rows( Z )


--------------------------------
General description:
--------------------------------

An object in CoFreyd( Rows( Z ) )

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( UnderlyingMorphism( KernelEmbedding( co_freyd_mor ) ) );</span>
Source: 
A row module over Z of rank 1

Matrix: 
[ [  1 ] ]

Range: 
A row module over Z of rank 1

An identity morphism in Rows( Z )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( CokernelObject( co_freyd_mor ) );</span>

--------------------------------
CoRelation morphism:
--------------------------------

Source: 
A row module over Z of rank 0

Matrix: 
(an empty 0 x 0 matrix)

Range: 
A row module over Z of rank 0

A morphism in Rows( Z )


--------------------------------
General description:
--------------------------------

An object in CoFreyd( Rows( Z ) )

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( UnderlyingMorphism( CokernelProjection( co_freyd_mor ) ) );</span>
Source: 
A row module over Z of rank 1

Matrix: 
(an empty 1 x 0 matrix)

Range: 
A row module over Z of rank 0

A morphism in Rows( Z )
</pre></div>

<p><a id="X82E68586814D020C" name="X82E68586814D020C"></a></p>

<h4>12.6 <span class="Heading">Cokernel image closure in category of rows</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := HomalgFieldOfRationalsInSingular() * "x,y,z";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RowsR := CategoryOfRows( R );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := AsCategoryOfRowsMorphism( </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    HomalgMatrix( "[[x],[y],[z]]", 3, 1, R ), RowsR</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mu := AsCokernelImageClosureMorphism( m );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := CokernelObject( mu );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C2 := AsFinitelyPresentedCokernelImageClosureObject( m );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForObjects( C, C2 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">n := AsCategoryOfRowsMorphism( </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    HomalgMatrix( "[[x,y],[y^2,z]]", 2, 2, R ), RowsR</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nu := AsCokernelImageClosureMorphism( n );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nu2 := PreCompose( nu, nu );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( nu2 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( nu, nu2 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nu + nu;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nu2 - nu;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cat := CapCategory( nu );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ZeroObject( cat );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ZeroMorphism( Source( nu ), Source( mu ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UniversalMorphismIntoZeroObject( Source( nu ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UniversalMorphismFromZeroObject( Source( nu ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Source( mu );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DirectSum( [S, S, S ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DirectSumFunctorial( [ nu2, nu ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UniversalMorphismIntoDirectSum( [ nu, nu ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UniversalMorphismFromDirectSum( [ nu, nu ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ProjectionInFactorOfDirectSum( [ S, S, S ], 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InjectionOfCofactorOfDirectSum( [ S, S, S, S ], 4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CokernelColift( nu, CokernelProjection( nu ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( nu, PreCompose( CoastrictionToImage( nu ), ImageEmbedding( nu ) ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := UniversalMorphismFromImage( nu, [ nu, IdentityMorphism( Range( nu ) ) ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( u );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( nu, PreCompose( CoastrictionToImage( nu ), u ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( u, ImageEmbedding( nu ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">kernel := KernelObject( mu );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">emb := KernelEmbedding( mu );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := PreCompose( EpimorphismFromSomeProjectiveObject( kernel ), KernelEmbedding( mu ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KernelLift( mu, p );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LiftAlongMonomorphism( emb, p );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">I_to_A := FunctorCokernelImageClosureToFreydCategory( RowsR );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A_to_I := FunctorFreydCategoryToCokernelImageClosure( RowsR );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor( I_to_A, kernel );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor( A_to_I, ApplyFunctor( I_to_A, kernel ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nu := NaturalIsomorphismFromIdentityToFinitePresentationOfCokernelImageClosureObject( RowsR );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mu := NaturalIsomorphismFromFinitePresentationOfCokernelImageClosureObjectToIdentity( RowsR );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    IdentityMorphism( kernel ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    PreCompose( ApplyNaturalTransformation( nu, kernel ), ApplyNaturalTransformation( mu, kernel ) )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);</span>
true
</pre></div>

<p><a id="X7FF5A0D086602294" name="X7FF5A0D086602294"></a></p>

<h4>12.7 <span class="Heading">Cokernel image closure in category of columns</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := HomalgFieldOfRationalsInSingular() * "x,y,z";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ColsR := CategoryOfColumns( R );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := AsCategoryOfColumnsMorphism( </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     HomalgMatrix( "[[x],[y],[z]]", 1, 3, R ), ColsR</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mu := AsCokernelImageClosureMorphism( m );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := CokernelObject( mu );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C2 := AsFinitelyPresentedCokernelImageClosureObject( m );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForObjects( C, C2 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">n := AsCategoryOfColumnsMorphism( </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    HomalgMatrix( "[[x,y],[y^2,z]]", 2, 2, R ), ColsR</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nu := AsCokernelImageClosureMorphism( n );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nu2 := PreCompose( nu, nu );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( nu2 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( nu, nu2 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nu + nu;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nu2 - nu;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cat := CapCategory( nu );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ZeroObject( cat );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ZeroMorphism( Source( nu ), Source( mu ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UniversalMorphismIntoZeroObject( Source( nu ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UniversalMorphismFromZeroObject( Source( nu ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Source( mu );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DirectSum( [S, S, S ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DirectSumFunctorial( [ nu2, nu ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UniversalMorphismIntoDirectSum( [ nu, nu ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UniversalMorphismFromDirectSum( [ nu, nu ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ProjectionInFactorOfDirectSum( [ S, S, S ], 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InjectionOfCofactorOfDirectSum( [ S, S, S, S ], 4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CokernelColift( nu, CokernelProjection( nu ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( nu, PreCompose( CoastrictionToImage( nu ), ImageEmbedding( nu ) ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := UniversalMorphismFromImage( nu, [ nu, IdentityMorphism( Range( nu ) ) ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( u );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( nu, PreCompose( CoastrictionToImage( nu ), u ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( u, ImageEmbedding( nu ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">kernel := KernelObject( mu );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">emb := KernelEmbedding( mu );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := PreCompose( EpimorphismFromSomeProjectiveObject( kernel ), KernelEmbedding( mu ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KernelLift( mu, p );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LiftAlongMonomorphism( emb, p );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">I_to_A := FunctorCokernelImageClosureToFreydCategory( ColsR );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A_to_I := FunctorFreydCategoryToCokernelImageClosure( ColsR );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor( I_to_A, kernel );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor( A_to_I, ApplyFunctor( I_to_A, kernel ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nu := NaturalIsomorphismFromIdentityToFinitePresentationOfCokernelImageClosureObject( ColsR );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mu := NaturalIsomorphismFromFinitePresentationOfCokernelImageClosureObjectToIdentity( ColsR );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    IdentityMorphism( kernel ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    PreCompose( ApplyNaturalTransformation( nu, kernel ), ApplyNaturalTransformation( mu, kernel ) )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);</span>
true
</pre></div>

<p><a id="X839428D58152A999" name="X839428D58152A999"></a></p>

<h4>12.8 <span class="Heading">Adelman category basics</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := HomalgRingOfIntegers();;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RowsR := CategoryOfRows( R );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">one := AsCategoryOfRowsMorphism( HomalgMatrix( [ [ 1 ] ], 1, 1, R ), RowsR );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">two := AsCategoryOfRowsMorphism( HomalgMatrix( [ [ 2 ] ], 1, 1, R ), RowsR );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">four := AsCategoryOfRowsMorphism( HomalgMatrix( [ [ 4 ] ], 1, 1, R ), RowsR );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">source := AdelmanCategoryObject( two, two );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">range := AdelmanCategoryObject( two, four );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mor := AdelmanCategoryMorphism( source, one, range );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForMorphisms( mor );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">emb := EmbeddingFunctorIntoFreydCategory( RowsR );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ind := AdelmanCategoryFunctorInducedByUniversalProperty( emb );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForMorphisms( ApplyFunctor( ind, mor ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M := FreydCategoryObject( AsCategoryOfRowsMorphism( HomalgMatrix( [ [  2, 2, 2 ], [ 4, 4, 6 ] ], 2, 3, R ), RowsR ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">as_tensor := EmbeddingFunctorOfFreydCategoryIntoAdelmanCategory( RowsR );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Mt := ApplyFunctor( as_tensor, M );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lsat := LeftSatelliteAsEndofunctorOfAdelmanCategory( RowsR );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rsat := RightSatelliteAsEndofunctorOfAdelmanCategory( RowsR );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">torsion := ApplyFunctor( ind, ( ApplyFunctor( rsat, ApplyFunctor( lsat, Mt ) ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">unit := UnitOfSatelliteAdjunctionOfAdelmanCategory( RowsR );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForMorphisms( ApplyNaturalTransformation( unit, Mt ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">counit := CounitOfSatelliteAdjunctionOfAdelmanCategory( RowsR );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t := ApplyNaturalTransformation( counit, Mt );;</span>
</pre></div>

<p><a id="X85F769C5823FAD20" name="X85F769C5823FAD20"></a></p>

<h4>12.9 <span class="Heading">Grade filtration</span></h4>

<p>The sequence of modules computed via satellites behaves in a way that is not understood in the case when the ring is not Auslander regular.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := HomalgFieldOfRationalsInSingular() * "x,y";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := R/"x*y"/"x^2";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RowsR := CategoryOfRows( R );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Freyd := FreydCategory( RowsR );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := HomalgMatrix( "[x,y]", 1, 2, R );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M := mat/Freyd;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mu1 := GradeFiltrationNthMonomorphism( M, 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMonomorphism( mu1 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZero( mu1 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEpimorphism( mu1 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mu2 := GradeFiltrationNthMonomorphism( M, 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIsomorphism( mu2 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZero( mu2 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mu3 := GradeFiltrationNthMonomorphism( M, 3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIsomorphism( mu3 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZero( mu3 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mu4 := GradeFiltrationNthMonomorphism( M, 4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMonomorphism( mu4 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEpimorphism( mu4 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZero( mu4 );</span>
false
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Qxyz := HomalgFieldOfRationalsInDefaultCAS( ) * "x,y,z";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">wmat := HomalgMatrix( "[ \</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">x*y,  y*z,    z,        0,         0,    \</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">x^3*z,x^2*z^2,0,        x*z^2,     -z^2, \</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">x^4,  x^3*z,  0,        x^2*z,     -x*z, \</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">0,    0,      x*y,      -y^2,      x^2-1,\</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">0,    0,      x^2*z,    -x*y*z,    y*z,  \</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">0,    0,      x^2*y-x^2,-x*y^2+x*y,y^2-y \</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">]", 6, 5, Qxyz );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RowsR := CategoryOfRows( Qxyz );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Freyd := FreydCategory( RowsR );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Adel := AdelmanCategory( RowsR );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M := wmat/Freyd;;</span>
</pre></div>

<p>We compute the grade sequence of functors (it turns out that on the level of functors, we don't get monos)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M_tor := M/Adel;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Mu1 := GradeFiltrationNthNaturalTransformationComponent( M_tor, 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZero( Mu1 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMonomorphism( Mu1 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Mu2 := GradeFiltrationNthNaturalTransformationComponent( M_tor, 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZero( Mu2 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMonomorphism( Mu2 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Mu3 := GradeFiltrationNthNaturalTransformationComponent( M_tor, 3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZero( Mu3 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMonomorphism( Mu3 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Mu4 := GradeFiltrationNthNaturalTransformationComponent( M_tor, 4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZero( Mu4 );</span>
true
</pre></div>

<p>We compute the grade sequence of modules (here, we really get monos and thus a filtration)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mu1 := GradeFiltrationNthMonomorphism( M, 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZero( mu1 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMonomorphism( mu1 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mu2 := GradeFiltrationNthMonomorphism( M, 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZero( mu2 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMonomorphism( mu2 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mu3 := GradeFiltrationNthMonomorphism( M, 3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZero( mu3 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMonomorphism( mu3 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mu4 := GradeFiltrationNthMonomorphism( M, 4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZero( mu4 );</span>
true
</pre></div>

<p><a id="X7E4FE96D7AD5A312" name="X7E4FE96D7AD5A312"></a></p>

<h4>12.10 <span class="Heading">Homomorphisms between f.p. functors based on category of rows</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := HomalgFieldOfRationalsInSingular() * "x,y,z";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Rows_R := CategoryOfRows( R );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R1 := CategoryOfRowsObject( 1, Rows_R );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R3 := CategoryOfRowsObject( 3, Rows_R );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := CategoryOfRowsMorphism( R3, HomalgMatrix( "[x,y,z]", 3, 1, R ), R1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M := FreydCategoryObject( alpha );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c0 := CovariantExtAsFreydCategoryObject( M, 0 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c1 := CovariantExtAsFreydCategoryObject( M, 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c2 := CovariantExtAsFreydCategoryObject( M, 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForObjects( HomomorphismStructureOnObjects( c0, c2 ) ); # = Ext^2( M, M )</span>
false
</pre></div>

<p><a id="X87D4D7857F0B6568" name="X87D4D7857F0B6568"></a></p>

<h4>12.11 <span class="Heading">Homomorphisms between f.p. functors based on category of columns</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := HomalgFieldOfRationalsInSingular() * "x,y,z";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Cols_R := CategoryOfColumns( R );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R1 := CategoryOfColumnsObject( 1, Cols_R );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R3 := CategoryOfColumnsObject( 3, Cols_R );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := CategoryOfColumnsMorphism( R3, HomalgMatrix( "[x,y,z]", 1, 3, R ), R1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M := FreydCategoryObject( alpha );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c0 := CovariantExtAsFreydCategoryObject( M, 0 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c1 := CovariantExtAsFreydCategoryObject( M, 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c2 := CovariantExtAsFreydCategoryObject( M, 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForObjects( HomomorphismStructureOnObjects( c0, c2 ) ); # = Ext^2( M, M )</span>
false
</pre></div>

<p><a id="X84C669D87B0599DB" name="X84C669D87B0599DB"></a></p>

<h4>12.12 <span class="Heading">Linear closure of categories</span></h4>


<div class="example"><pre>
#@if IsPackageMarkedForLoading( "FinSetsForCAP", "&gt;= 2023.07-03" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := SymmetricGroup( 3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CG := GroupAsCategory( G );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compare_func := function( g, h ) return UnderlyingGroupElement( g ) &lt; UnderlyingGroupElement( h ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ZZZ := HomalgRingOfIntegers();;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ZCG := LinearClosure( ZZZ, CG, compare_func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := GroupAsCategoryUniqueObject( CG );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := GroupAsCategoryMorphism( (1,2,3), CG );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h := GroupAsCategoryMorphism( (1,2), CG );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">v := LinearClosureObject( ZCG, u );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetOfObjectsOfCategory( ZCG ) = [ v ];</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">elem1 := LinearClosureMorphism( v, [ 1, 2, 3, 4, 5, 6 ], [ g, h, g, h, g, h ], v );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">elem2 := LinearClosureMorphism( v, [ 1, 2, 3, 4, 5, 6 ], [ h, g, h, g, h, g ], v );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># for i in [ 1 .. 10^6 ] do LinearClosureMorphism( v, [ 1, 2, 3, 4, 5, 6 ], [ g, h, g, h, g, h ], v ); od;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">elem := LinearClosureMorphism( v, [ 0, 0, 0, 0, 0, 0 ], [ g, h, g, h, g, h ], v );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := (1,2)/CG/ZCG;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">b := (2,3)/CG/ZCG;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIsomorphism( a + b );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Lift( a + b, a ) * a = a + b;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLiftable( a + b, -2*a ); ## over Q this is liftable</span>
false
#@fi
</pre></div>

<p><a id="X81E7031D85FD2569" name="X81E7031D85FD2569"></a></p>

<h4>12.13 <span class="Heading">Matrices over ZP K</span></h4>


<div class="example"><pre>
#@if IsPackageMarkedForLoading( "FinSetsForCAP", "&gt;= 2023.07-03" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">#Incidence matrix of our proset</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">K := [ [1, 1, 1], [0, 1, 1], [0, 1, 1] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">#Construction of a tower of categories</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">CP_K := ProSetAsCategory( K );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ZZZ := HomalgRingOfIntegers( );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ZP_K := LinearClosure( ZZZ, CP_K, ReturnTrue );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RowsP_K := AdditiveClosure( ZP_K );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := ProSetAsCategoryObject( 1, CP_K );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">b := ProSetAsCategoryObject( 2, CP_K );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c := ProSetAsCategoryObject( 3, CP_K );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">#Three random objects in the additive closure</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">#Such that there exists morphisms from A-&gt;B and B-&gt;C:</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">rand_coef := List( [ 1 .. 5 ], i -&gt; Random( [ 2 .. 20 ] ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A1 := List( [ 1 .. rand_coef[ 1 ] ], i -&gt; a );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A2 := List( [ 1 .. rand_coef[ 2 ] ], i -&gt; b );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A := Concatenation( A1, A2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B1 := List( [ 1 .. rand_coef[ 3 ] ], i -&gt; b );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B2 := List( [ 1 .. rand_coef[ 4 ] ], i -&gt; c );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B :=  Concatenation( B1, B2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := List([ 1 .. rand_coef[ 5 ] ], i -&gt; c);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">#A random lifting problem over ZP_K</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">MA_B :=  List( [ 1 .. rand_coef[ 1 ] + rand_coef[ 2 ] ], i -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            List( [ 1 .. rand_coef[ 3 ] + rand_coef[ 4 ] ], j -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                LinearClosureMorphism( LinearClosureObject( A[i], ZP_K ), [Random( [ -20 .. 20 ] )], [ProSetAsCategoryMorphism( A[i], B[j] )], LinearClosureObject( B[j], ZP_K ) )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := MA_B/RowsP_K;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MB_C :=  List( [ 1 .. rand_coef[ 3 ] + rand_coef[ 4 ] ], i -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            List( [ 1 .. rand_coef[ 5 ] ], j -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                LinearClosureMorphism( LinearClosureObject( B[i], ZP_K ), [Random( [ -20 .. 20 ] )], [ProSetAsCategoryMorphism( B[i], C[j] )], LinearClosureObject( C[j], ZP_K ) )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">beta := MB_C/RowsP_K;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gamma := PreCompose( alpha, beta );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lift := Lift( gamma, beta );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PreCompose(lift, beta) = gamma;</span>
true
#@fi
</pre></div>

<p><a id="X7F1E3F5A7EC538B6" name="X7F1E3F5A7EC538B6"></a></p>

<h4>12.14 <span class="Heading">Matrices over ZG</span></h4>

<p>Construction of a tower of categories</p>


<div class="example"><pre>
#@if IsPackageMarkedForLoading( "FinSetsForCAP", "&gt;= 2023.07-03" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := SymmetricGroup( 3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CG := GroupAsCategory( G );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ZZZ := HomalgRingOfIntegers( );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ZCG := LinearClosure( ZZZ, CG );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RowsG := AdditiveClosure( ZCG );;</span>
#@fi
</pre></div>

<p>Construction of elements</p>


<div class="example"><pre>
#@if IsPackageMarkedForLoading( "FinSetsForCAP", "&gt;= 2023.07-03" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := (1,2)/CG/ZCG;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">b := (2,3)/CG/ZCG;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">e := ()/CG/ZCG;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">omega := [ [ a - e ], [ b - e ] ]/RowsG;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := GroupAsCategoryUniqueObject( CG );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">v := LinearClosureObject( ZCG, u );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := AsAdditiveClosureObject( v );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HomStructure( u, omega );;</span>
#@fi
</pre></div>

<p>A random lifting problem over ZG</p>


<div class="example"><pre>
#@if IsPackageMarkedForLoading( "FinSetsForCAP", "&gt;= 2023.07-03" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">elem := Elements( G );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">elem := List( elem, x -&gt; x/CG/ZCG );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rand_elem := function() local coeffs; coeffs := List( [ 1 .. 6 ], i -&gt; Random( [ -20 .. 20 ] ) ); if ForAll( coeffs, IsZero ) then return ZeroMorphism( v, v ); fi; return Sum( List( [ 1 .. 6 ], i -&gt; Random( [ -20 .. 20 ] ) * One( ZZZ ) * elem[i] ) ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat10_11 := List( [ 1 .. 10 ], i -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        List( [ 1 .. 11 ], j -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            rand_elem()</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat11_12 := List( [ 1 .. 11 ], i -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        List( [ 1 .. 12 ], j -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            rand_elem()</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := mat10_11/RowsG;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">beta := mat11_12/RowsG;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gamma := PreCompose( alpha, beta );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lift := Lift( gamma, beta );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PreCompose( lift, beta ) = gamma;</span>
true
#@fi
</pre></div>

<p><a id="X820CD9B28165BF9F" name="X820CD9B28165BF9F"></a></p>

<h4>12.15 <span class="Heading">Testing if an object is projective, injective, bijective, and computing projective/injective dimensions</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := HomalgRingOfIntegers();;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rows := CategoryOfRows( R );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">adelman := AdelmanCategory( rows );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rowobj := CategoryOfRowsObject( 1, rows );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := ProjectionInFactorOfDirectSum( [ rowobj, rowobj ], 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := AsAdelmanCategoryMorphism( alpha );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj := CokernelObject( alpha );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsBijectiveObject( obj );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">beta := 2 * IdentityMorphism( rowobj );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">beta := AsAdelmanCategoryMorphism( beta );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj1 := CokernelObject( beta );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj2 := KernelObject( beta );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj3 := ImageObject( beta );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj4 := HomologyObject( beta, beta );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsBijectiveObject( obj1 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsInjective( obj1 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ProjectiveDimension( obj1 );</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsBijectiveObject( obj2 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsProjective( obj2 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InjectiveDimension( obj2 );</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ProjectiveDimension( obj3 );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InjectiveDimension( obj3 );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ProjectiveDimension( obj4 );</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InjectiveDimension( obj4 );</span>
2
</pre></div>

<p><a id="X7AFC8F247C00D608" name="X7AFC8F247C00D608"></a></p>

<h4>12.16 <span class="Heading">Prosets</span></h4>


<div class="example"><pre>
#@if IsPackageMarkedForLoading( "FinSetsForCAP", "&gt;= 2023.07-03" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">K := [ [1, 1, 1], [0, 1, 1], [0, 1, 1] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L := [ [1, 1, 0], [0, 1, 1], [0, 0, 1] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P_K := ProSetAsCategory(K);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">#ProSetAsCategory(L);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := 1/P_K;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">b := ProSetAsCategoryObject(2, P_K);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c := ProSetAsCategoryObject(3, P_K);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d := ProSetAsCategoryObject(4, P_K);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">delta := ProSetAsCategoryMorphism(b, a);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined(a);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined(d);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined(delta);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := ProSetAsCategoryMorphism(a, b);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">beta := ProSetAsCategoryMorphism(b, c);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gamma := ProSetAsCategoryMorphism(a, c);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gamma = PreCompose(alpha, beta);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">id_a := IdentityMorphism(a);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined(Inverse(alpha));</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">beta*Inverse(beta) = IdentityMorphism(b);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha = Lift(gamma, beta);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLiftable(beta, gamma);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Colift(alpha, gamma) = beta;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha = HomStructure(a, b, HomStructure(alpha));</span>
true
#@fi
</pre></div>

<p><a id="X789E61CF843CF960" name="X789E61CF843CF960"></a></p>

<h4>12.17 <span class="Heading">Category of relations</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F := HomalgRingOfIntegers( 3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">vec := CategoryOfRows( F );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rel := RelCategory( vec );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A := 1/vec/rel;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">id := IdentityMorphism( A );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( id );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := HomalgMatrix( "[ 1, 2 ]", 2, 1, F )/vec;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha_rel := alpha/rel;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha_rel_inv := rel/alpha;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">beta := PreCompose( alpha_rel_inv, alpha_rel );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( beta, id );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForMorphisms( beta, id );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := HomalgFieldOfRationalsInSingular() * "t";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t := IndeterminatesOfPolynomialRing( R )[1];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cocycle := function( a, b, c ) local e; e := CoastrictionToImage( UniversalMorphismIntoDirectSum( [ ReversedArrow( c ), Arrow( c ) ] ) ); return t^RankOfObject( KernelObject( e ) ); end;;</span>
#@if IsPackageMarkedForLoading( "FinSetsForCAP", "&gt;= 2023.07-03" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T := TwistedLinearClosure( R, rel, cocycle );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gamma := beta/T;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">delta := ZeroMorphism( 1/vec, 1/vec )/rel/T;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForMorphisms( 3*gamma - 3*gamma );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( delta, gamma );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">beta := PreCompose( alpha_rel_inv/T, alpha_rel/T );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForMorphisms( beta - t * IdentityMorphism( Range( alpha_rel/T ) ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForMorphisms( ( gamma * delta ) * gamma - gamma * ( delta * gamma ) );</span>
true
#@fi
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap11_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap13_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chap10_mj.html">10</a>  <a href="chap11_mj.html">11</a>  <a href="chap12_mj.html">12</a>  <a href="chap13_mj.html">13</a>  <a href="chap14_mj.html">14</a>  <a href="chap15_mj.html">15</a>  <a href="chap16_mj.html">16</a>  <a href="chap17_mj.html">17</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="https://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
